/*
===========================================================================
Copyright (C) 1999 - 2005, Id Software, Inc.
Copyright (C) 2000 - 2013, Raven Software, Inc.
Copyright (C) 2001 - 2013, Activision, Inc.
Copyright (C) 2005 - 2015, ioquake3 contributors
Copyright (C) 2013 - 2015, OpenJK contributors

This file is part of the OpenJK source code.

OpenJK is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License version 2 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, see <http://www.gnu.org/licenses/>.
===========================================================================
*/

// cg_ents.c -- present snapshot entities, happens every single frame

#include "cg_local.h"
#include "cg_weapons.h"
/*
Ghoul2 Insert Start
*/
#include "qcommon/q_shared.h"
#include "ghoul2/G2.h"
/*
Ghoul2 Insert end
*/

static void CG_Missile( centity_t *cent );

/*
======================
CG_PositionEntityOnTag

Modifies the entities position and axis by the given
tag location
======================
*/
void CG_PositionEntityOnTag( refEntity_t *entity, const refEntity_t *parent, 
							qhandle_t parentModel, const char *tagName ) {
	int				i;
	orientation_t	lerped;
	
	// lerp the tag
	trap->R_LerpTag( &lerped, parentModel, parent->oldframe, parent->frame,
		1.0f - parent->backlerp, tagName );

	// FIXME: allow origin offsets along tag?
	VectorCopy( parent->origin, entity->origin );
	for ( i = 0 ; i < 3 ; i++ ) {
		VectorMA( entity->origin, lerped.origin[i], parent->axis[i], entity->origin );
	}

	// had to cast away the const to avoid compiler problems...
	MatrixMultiply( lerped.axis, ((refEntity_t *)parent)->axis, entity->axis );
	entity->backlerp = parent->backlerp;
}


/*
======================
CG_PositionRotatedEntityOnTag

Modifies the entities position and axis by the given
tag location
======================
*/
void CG_PositionRotatedEntityOnTag( refEntity_t *entity, const refEntity_t *parent, 
							qhandle_t parentModel, const char *tagName ) {
	int				i;
	orientation_t	lerped;
	vec3_t			tempAxis[3];

//AxisClear( entity->axis );
	// lerp the tag
	trap->R_LerpTag( &lerped, parentModel, parent->oldframe, parent->frame,
		1.0f - parent->backlerp, tagName );

	// FIXME: allow origin offsets along tag?
	VectorCopy( parent->origin, entity->origin );
	for ( i = 0 ; i < 3 ; i++ ) {
		VectorMA( entity->origin, lerped.origin[i], parent->axis[i], entity->origin );
	}

	// had to cast away the const to avoid compiler problems...
	MatrixMultiply( entity->axis, lerped.axis, tempAxis );
	MatrixMultiply( tempAxis, ((refEntity_t *)parent)->axis, entity->axis );
}



/*
==========================================================================

FUNCTIONS CALLED EACH FRAME

==========================================================================
*/

//only need to use the CG_S_ system when you want a looping sound that isn't going to add itself
//via trap each frame. Such as ones generated by events.
/*
======================
CG_SetEntitySoundPosition

Also called by event processing code
======================
*/
void CG_SetEntitySoundPosition( centity_t *cent ) {
	if ( cent->currentState.solid == SOLID_BMODEL )
	{
		vec3_t	origin;
		float	*v;

		v = cgs.inlineModelMidpoints[ cent->currentState.modelindex ];
		VectorAdd( cent->lerpOrigin, v, origin );
		trap->S_UpdateEntityPosition( cent->currentState.number, origin );
	}
	else
	{
		trap->S_UpdateEntityPosition( cent->currentState.number, cent->lerpOrigin );
	}
}

/*
==================
CG_S_AddLoopingSound

Set the current looping sounds on the entity.
==================
*/
void CG_S_AddLoopingSound(int entityNum, const vec3_t origin, const vec3_t velocity, sfxHandle_t sfx)
{
	centity_t *cent = &cg_entities[entityNum];
	cgLoopSound_t *cSound = NULL;
	int i = 0;
	qboolean alreadyPlaying = qfalse;

	//first see if we're already looping this sound handle.
	while (i < cent->numLoopingSounds)
	{
		cSound = &cent->loopingSound[i];

		if (cSound->sfx == sfx)
		{
			alreadyPlaying = qtrue;
			break;
		}
		i++;
	}
	
	if (alreadyPlaying && cSound)
	{ //if this is the case, just update the properties of the looping sound and return.
		VectorCopy(origin, cSound->origin);
		VectorCopy(velocity, cSound->velocity);
	}
	else if (cent->numLoopingSounds >= MAX_CG_LOOPSOUNDS)
	{ //Just don't add it then I suppose.
		return;
	}

	//Add a new looping sound.
	cSound = &cent->loopingSound[cent->numLoopingSounds];

	cSound->entityNum = entityNum;
	VectorCopy(origin, cSound->origin);
	VectorCopy(velocity, cSound->velocity);
	cSound->sfx = sfx;

	cent->numLoopingSounds++;
}

/*
==================
CG_S_AddLoopingSound

For now just redirect, might eventually do something different.
==================
*/
void CG_S_AddRealLoopingSound(int entityNum, const vec3_t origin, const vec3_t velocity, sfxHandle_t sfx)
{
	CG_S_AddLoopingSound(entityNum, origin, velocity, sfx);
}

/*
==================
CG_S_AddLoopingSound

Clear looping sounds.
==================
*/
void CG_S_StopLoopingSound(int entityNum, sfxHandle_t sfx)
{
	centity_t *cent = &cg_entities[entityNum];
	cgLoopSound_t *cSound;

	if (sfx == -1)
	{ //clear all the looping sounds on the entity
		cent->numLoopingSounds = 0;
	}
	else
	{ //otherwise, clear only the specified looping sound
		int i = 0;

		while (i < cent->numLoopingSounds)
		{
			cSound = &cent->loopingSound[i];

			if (cSound->sfx == sfx)
			{ //remove it then
				int x = i+1;

				while (x < cent->numLoopingSounds)
				{
					memcpy(&cent->loopingSound[x-1], &cent->loopingSound[x], sizeof(cent->loopingSound[x]));
					x++;
				}
				cent->numLoopingSounds--;
			}

			i++;
		}
	}
	//trap->S_StopLoopingSound(entityNum);
}

/*
==================
CG_S_UpdateLoopingSounds

Update any existing looping sounds on the entity.
==================
*/
void CG_S_UpdateLoopingSounds(int entityNum)
{
	centity_t *cent = &cg_entities[entityNum];
	cgLoopSound_t *cSound;
	vec3_t lerpOrg;
	float *v;
	int i = 0;

	if (!cent->numLoopingSounds)
	{
		return;
	}

	if (cent->currentState.eType == ET_MOVER)
	{
		v = cgs.inlineModelMidpoints[ cent->currentState.modelindex ];
		VectorAdd( cent->lerpOrigin, v, lerpOrg );
	}
	else
	{
		VectorCopy(cent->lerpOrigin, lerpOrg);
	}

	//Raz: Looping sounds fix from Sil
	/*	Sil: well with looping sounds, you would notice it playing with force powers
		Sil: when someone turns on speed
		Sil: or rage
		Sil: etc
		Sil: you will hear it in origin where he turned it on
		Sil: even if he is not there anymore
	*/
	if ( (cent->currentState.eFlags & EF_SOUNDTRACKER)
		&& (!cg.snap || cent->currentState.trickedentindex != cg.snap->ps.clientNum) )
	{//keep sound for this entity updated in accordance with its attached entity at all times
		//entity out of range
		if ( !cg_entities[cent->currentState.trickedentindex].currentValid )
			return;

		VectorCopy( cg_entities[cent->currentState.trickedentindex].lerpOrigin, lerpOrg );
	}

	while (i < cent->numLoopingSounds)
	{
		cSound = &cent->loopingSound[i];

		//trap->S_AddLoopingSound(entityNum, cSound->origin, cSound->velocity, cSound->sfx);
		//I guess just keep using lerpOrigin for now,
		trap->S_AddLoopingSound(entityNum, lerpOrg, cSound->velocity, cSound->sfx);
		i++;
	}
}

/*
==================
CG_EntityEffects

Add continuous entity effects, like local entity emission and lighting
==================
*/
static void CG_EntityEffects( centity_t *cent ) {

	if( !cent ) return;

	// update sound origins
	CG_SetEntitySoundPosition( cent );

	// add loop sound
	if ( cent->currentState.loopSound || ((cent->currentState.loopIsSoundset && cent->currentState.number >= MAX_CLIENTS) 
		&& cent->currentState.loopSound < MAX_SOUNDS)) {
		sfxHandle_t realSoundIndex = -1;
			
		if (cent->currentState.loopIsSoundset && cent->currentState.number >= MAX_CLIENTS)
		{ //If this is so, then first get our soundset from the index, and loopSound actually contains which part of the set to
		  //use rather than a sound index (BMS_START [0], BMS_MID [1], or BMS_END [2]). Typically loop sounds will be BMS_MID.
			const char *soundSet;
			
			soundSet = CG_ConfigString( CS_AMBIENT_SET + cent->currentState.soundSetIndex );

			if (soundSet && soundSet[0])
			{
				realSoundIndex = trap->AS_GetBModelSound(soundSet, cent->currentState.loopSound);
			}
		}
		else
		{
			realSoundIndex = cgs.gameSounds[ cent->currentState.loopSound ];
		}

		//rww - doors and things with looping sounds have a crazy origin (being brush models and all)
		if (realSoundIndex != -1)
		{
			if ( cent->currentState.solid == SOLID_BMODEL )
			{
				vec3_t	origin;
				float	*v;

				v = cgs.inlineModelMidpoints[ cent->currentState.modelindex ];
				VectorAdd( cent->lerpOrigin, v, origin );
				trap->S_AddLoopingSound( cent->currentState.number, origin, vec3_origin, 
					realSoundIndex );
			}
			else if (cent->currentState.eType != ET_SPEAKER) {
				trap->S_AddLoopingSound( cent->currentState.number, cent->lerpOrigin, vec3_origin, 
					realSoundIndex );
			} else {
				trap->S_AddLoopingSound( cent->currentState.number, cent->lerpOrigin, vec3_origin, 
					realSoundIndex );
			}
		}
	}


	// constant light glow
	//Raz: Fix the glow from charging weapons being stuck to players
	if ( cent->currentState.constantLight && cent->currentState.eType != ET_PLAYER && cent->currentState.eType != ET_BODY && cent->currentState.eType != ET_NPC && cent->currentState.eType != ET_INVISIBLE ) {
		int		cl;
		float	i, r, g, b;

		cl = cent->currentState.constantLight;
		r = (float) (cl & 0xFF) / 255.0;
		g = (float) ((cl >> 8) & 0xFF) / 255.0;
		b = (float) ((cl >> 16) & 0xFF) / 255.0;
		i = (float) ((cl >> 24) & 0xFF) * 4.0;

		trap->R_AddLightToScene( cent->lerpOrigin, i, r, g, b );
	}

}

/*
==================
CG_Special
Not used.
==================
*/
void CG_Special( centity_t *cent ) {
	return;
}

/*
Ghoul2 Insert Start
*/

// Copy the ghoul2 data into the ref ent correctly
void CG_SetGhoul2Info( refEntity_t *ent, const centity_t *cent)
{

	ent->ghoul2 = cent->ghoul2;
	VectorCopy( cent->modelScale, ent->modelScale);
	ent->radius = cent->radius;
	VectorCopy (cent->lerpAngles, ent->angles);
}

// write in the axis and stuff
void G2_BoltToGhoul2Model(centity_t *cent, refEntity_t *ent)
{
		// extract the wraith ID from the bolt info
	int modelNum = cent->boltInfo >> MODEL_SHIFT;
	int boltNum	= cent->boltInfo >> BOLT_SHIFT;
	int	entNum = cent->boltInfo >> ENTITY_SHIFT;
 	mdxaBone_t 		boltMatrix;
	
	modelNum &= MODEL_AND;
	boltNum &= BOLT_AND;
	entNum &= ENTITY_AND;


	//NOTENOTE I put this here because the cgs.gamemodels array no longer gets initialized.
	assert(0);		


 	// go away and get me the bolt position for this frame please
	trap->G2API_GetBoltMatrix(cent->ghoul2, modelNum, boltNum, &boltMatrix, cg_entities[entNum].currentState.angles, cg_entities[entNum].currentState.origin, cg.time, cgs.gameModels, cent->modelScale);

	// set up the axis and origin we need for the actual effect spawning
 	ent->origin[0] = boltMatrix.matrix[0][3];
 	ent->origin[1] = boltMatrix.matrix[1][3];
 	ent->origin[2] = boltMatrix.matrix[2][3];

 	ent->axis[0][0] = boltMatrix.matrix[0][0];
 	ent->axis[0][1] = boltMatrix.matrix[1][0];
 	ent->axis[0][2] = boltMatrix.matrix[2][0];

 	ent->axis[1][0] = boltMatrix.matrix[0][1];
 	ent->axis[1][1] = boltMatrix.matrix[1][1];
 	ent->axis[1][2] = boltMatrix.matrix[2][1];

 	ent->axis[2][0] = boltMatrix.matrix[0][2];
 	ent->axis[2][1] = boltMatrix.matrix[1][2];
 	ent->axis[2][2] = boltMatrix.matrix[2][2];
}

void ScaleModelAxis(refEntity_t	*ent)

{		// scale the model should we need to
		if (ent->modelScale[0] && ent->modelScale[0] != 1.0f)
		{
			VectorScale( ent->axis[0], ent->modelScale[0] , ent->axis[0] );
			ent->nonNormalizedAxes = qtrue;
		}
		if (ent->modelScale[1] && ent->modelScale[1] != 1.0f)
		{
			VectorScale( ent->axis[1], ent->modelScale[1] , ent->axis[1] );
			ent->nonNormalizedAxes = qtrue;
		}
		if (ent->modelScale[2] && ent->modelScale[2] != 1.0f)
		{
			VectorScale( ent->axis[2], ent->modelScale[2] , ent->axis[2] );
			ent->nonNormalizedAxes = qtrue;
		}
}
/*
Ghoul2 Insert End
*/

void CG_Disintegration(centity_t *cent, refEntity_t *ent)
{
	vec3_t tempAng, hitLoc;
	float tempLength;

	VectorCopy(cent->currentState.origin2, hitLoc);

	VectorSubtract( hitLoc, ent->origin, ent->oldorigin );
	
	tempLength = VectorNormalize( ent->oldorigin );
	vectoangles( ent->oldorigin, tempAng );
	tempAng[YAW] -= cent->lerpAngles[YAW];
	AngleVectors( tempAng, ent->oldorigin, NULL, NULL );
	VectorScale( ent->oldorigin, tempLength, ent->oldorigin );

	ent->endTime = cent->dustTrailTime;

	ent->renderfx |= RF_DISINTEGRATE2;
	ent->customShader = cgs.media.disruptorShader;
	trap->R_AddRefEntityToScene( ent );

	ent->renderfx &= ~(RF_DISINTEGRATE2);
	ent->renderfx |= (RF_DISINTEGRATE1);
	ent->customShader = 0;
	trap->R_AddRefEntityToScene( ent );

	if ( cg.time - ent->endTime < 1000 && (timescale.value * timescale.value * random()) > 0.05f )
	{
		vec3_t fxOrg, fxDir;
		mdxaBone_t	boltMatrix;
		int torsoBolt = trap->G2API_AddBolt(cent->ghoul2, 0, "lower_lumbar");

		VectorSet(fxDir, 0, 1, 0);

		trap->G2API_GetBoltMatrix( cent->ghoul2, 0, torsoBolt, &boltMatrix, cent->lerpAngles, cent->lerpOrigin, cg.time, 
				cgs.gameModels, cent->modelScale);
				BG_GiveMeVectorFromMatrix( &boltMatrix, ORIGIN, fxOrg );

		VectorMA( fxOrg, -18, cg.refdef.viewaxis[0], fxOrg );
		fxOrg[2] += crandom() * 20;
		trap->FX_PlayEffectID( cgs.effects.mDisruptorDeathSmoke, fxOrg, fxDir, -1, -1, false );

		if ( random() > 0.5f )
		{
			trap->FX_PlayEffectID( cgs.effects.mDisruptorDeathSmoke, fxOrg, fxDir, -1, -1, false );
		}
	}
}

static qboolean CG_RenderTimeEntBolt(centity_t *cent)
{
	int clientNum = cent->currentState.boltToPlayer-1;
	centity_t *cl;
	mdxaBone_t matrix;
	vec3_t boltOrg, boltAng;
	int getBolt = -1;

	if (clientNum >= MAX_CLIENTS || clientNum < 0)
	{
		assert(0);
		return qfalse;
	}

	cl = &cg_entities[clientNum];

	if (!cl->ghoul2)
	{
		assert(0);
		return qfalse;
	}

	getBolt = trap->G2API_AddBolt(cl->ghoul2, 0, "lhand");

	trap->G2API_GetBoltMatrix(cl->ghoul2, 0, getBolt, &matrix, cl->turAngles, cl->lerpOrigin, cg.time, cgs.gameModels, cl->modelScale);

	BG_GiveMeVectorFromMatrix(&matrix, ORIGIN, boltOrg);
	BG_GiveMeVectorFromMatrix(&matrix, NEGATIVE_Y, boltAng);
	vectoangles(boltAng, boltAng);
	boltAng[PITCH] = boltAng[ROLL] = 0;

	VectorCopy(boltOrg, cent->lerpOrigin);
	VectorCopy(boltAng, cent->lerpAngles);

	return qtrue;
}

void CG_AddRadarEnt(centity_t *cent) 
{
	static const size_t numRadarEnts = ARRAY_LEN( cg.radarEntities );
	if (cg.radarEntityCount >= numRadarEnts)
	{	
#ifdef _DEBUG
		Com_Printf("^3Warning: CG_AddRadarEnt full. (%d max)\n", numRadarEnts);
#endif
		return;
	}
	cg.radarEntities[cg.radarEntityCount++] = cent->currentState.number;
}

/*
==================
CG_General
==================
*/
void CG_G2ServerBoneAngles(centity_t *cent);

extern qboolean BG_GetRootSurfNameWithVariant( void *ghoul2, const char *rootSurfName, char *returnSurfName, int returnSize );

static void CG_General( centity_t *cent ) {
	refEntity_t			ent;
	entityState_t		*s1;
	float				val;
	int					beamID, i;
	vec3_t				beamOrg;
	mdxaBone_t			matrix;
	qboolean			doNotSetModel = qfalse;

	if (cent->currentState.modelGhoul2 == 127)
	{ //not ready to be drawn or initialized..
		return;
	}
	
	switch ( cent->currentState.weapon )
	{
	    case WP_TRIP_MINE:
	    case WP_DET_PACK:
			JKG_RenderExplosive (cent, cent->currentState.firingMode);
	        return;
	        
	    default:
	        break;
	}

	if (cent->ghoul2 && !cent->currentState.modelGhoul2 && cent->currentState.eType != ET_BODY &&
		cent->currentState.number >= MAX_CLIENTS)
	{ //this is a bad thing
		if (trap->G2_HaveWeGhoul2Models(cent->ghoul2))
		{
			trap->G2API_CleanGhoul2Models(&(cent->ghoul2));
		}
	}
	
	if (cent->currentState.eFlags & EF_RADAROBJECT)
	{
		CG_AddRadarEnt(cent);
	}
	
	if (cent->currentState.boltToPlayer)
	{ //Shove it into the player's left hand then.
		centity_t *pl = &cg_entities[cent->currentState.boltToPlayer-1];
		if (CG_IsMindTricked(pl->currentState.trickedentindex,
			pl->currentState.trickedentindex2,
			pl->currentState.trickedentindex3,
			pl->currentState.trickedentindex4,
			cg.predictedPlayerState.clientNum))
		{ //don't show if this guy is mindtricking
            return;
		}
		if (!CG_RenderTimeEntBolt(cent))
		{ //If this function returns qfalse we shouldn't render this ent at all.
			if (cent->currentState.boltToPlayer > 0 &&
				(cent->currentState.boltToPlayer <= MAX_CLIENTS || cent->currentState.eType == ET_NPC))
			{
				VectorCopy(pl->lerpOrigin, cent->lerpOrigin);

				if (cent->currentState.eFlags & EF_CLIENTSMOOTH)
				{ //if it's set to smooth keep the smoothed lerp origin updated, as we don't want to smooth while bolted.
					VectorCopy(cent->lerpOrigin, cent->turAngles);
				}
			}
			return;
		}

		if (cent->currentState.eFlags & EF_CLIENTSMOOTH)
		{ //if it's set to smooth keep the smoothed lerp origin updated, as we don't want to smooth while bolted.
			VectorCopy(cent->lerpOrigin, cent->turAngles);
		}
	}
	else if (cent->currentState.eFlags & EF_CLIENTSMOOTH)
	{
		if (cent->currentState.groundEntityNum >= ENTITYNUM_WORLD)
		{
			float smoothFactor = 0.5f*timescale.value;
			int k = 0;
			vec3_t posDif;

			//Use origin smoothing since dismembered limbs use ExPhys
			if (DistanceSquared(cent->turAngles,cent->lerpOrigin)>18000.0f)
			{
				VectorCopy(cent->lerpOrigin, cent->turAngles);
			}

			VectorSubtract(cent->lerpOrigin, cent->turAngles, posDif);
			
			for (k=0;k<3;k++)
			{
				cent->turAngles[k]=(cent->turAngles[k]+posDif[k]*smoothFactor);
				cent->lerpOrigin[k]=cent->turAngles[k];
			}
		}
		else
		{ //if we're sitting on an entity like a moving plat then we don't want to smooth either
			VectorCopy(cent->lerpOrigin, cent->turAngles);
		}
	}

	//rww - now do ragdoll stuff
	if (cent->ghoul2 &&
		(cent->currentState.eType == ET_BODY || (cent->currentState.eFlags & EF_RAG)))
	{
		if (!(cent->currentState.eFlags & EF_NODRAW) &&
			!(cent->currentState.eFlags & EF_DISINTEGRATION) &&
			cent->bodyFadeTime <= cg.time)
		{
			vec3_t forcedAngles;

			VectorClear(forcedAngles);
			forcedAngles[YAW] = cent->lerpAngles[YAW];

			CG_RagDoll(cent, forcedAngles);
		}
	}
	else if (cent->isRagging)
	{
		cent->isRagging = qfalse;

		if (cent->ghoul2 && trap->G2_HaveWeGhoul2Models(cent->ghoul2))
		{ //May not be valid, in the case of a ragged entity being removed and a non-g2 ent filling its slot.
			trap->G2API_SetRagDoll(cent->ghoul2, NULL); //calling with null parms resets to no ragdoll.
		}
	}

	if (cent->currentState.boneOrient && cent->ghoul2)
	{ //server sent us some bone angles to use
		CG_G2ServerBoneAngles(cent);
	}

	if ((cent->currentState.eFlags & EF_G2ANIMATING) && cent->ghoul2)
	{ //mini-animation routine for general objects that want to play quick ghoul2 anims
		//obviously lacks much of the functionality contained in player/npc animation.
		//we actually use torsoAnim as the start frame and legsAnim as the end frame and
		//always play the anim on the root bone.
		if (cent->currentState.torsoAnim != cent->pe.torso.animationNumber ||
			cent->currentState.legsAnim != cent->pe.legs.animationNumber ||
			cent->currentState.torsoFlip != cent->pe.torso.lastFlip)
		{
			trap->G2API_SetBoneAnim(cent->ghoul2, 0, "model_root", cent->currentState.torsoAnim,
				cent->currentState.legsAnim, (BONE_ANIM_OVERRIDE_FREEZE|BONE_ANIM_BLEND), 1.0f, cg.time, -1, 100);

			cent->pe.torso.animationNumber = cent->currentState.torsoAnim;
			cent->pe.legs.animationNumber = cent->currentState.legsAnim;
			cent->pe.torso.lastFlip = cent->currentState.torsoFlip;
		}
	}

	memset (&ent, 0, sizeof(ent));

	ent.shaderRGBA[0] = cent->currentState.customRGBA[0];
	ent.shaderRGBA[1] = cent->currentState.customRGBA[1];
	ent.shaderRGBA[2] = cent->currentState.customRGBA[2];
	ent.shaderRGBA[3] = cent->currentState.customRGBA[3];

	if (cent->currentState.modelGhoul2 >= G2_MODELPART_HEAD &&
		cent->currentState.modelGhoul2 <= G2_MODELPART_RLEG &&
		/*cent->currentState.modelindex < MAX_CLIENTS &&*/
		cent->currentState.weapon == G2_MODEL_PART)
	{ //special case for client limbs
		centity_t *clEnt;
		int dismember_settings = cg_dismember.integer;
		float smoothFactor = 0.5f*timescale.value;
		int k = 0;
		vec3_t posDif;
		
		doNotSetModel = qtrue;

		if (cent->currentState.modelindex >= 0)
		{
			clEnt = &cg_entities[cent->currentState.modelindex];
		}
		else
		{
			clEnt = &cg_entities[cent->currentState.otherEntityNum2];
		}

		if (!dismember_settings)
		{ //This client does not wish to see dismemberment.
			return;
		}

		if (dismember_settings < 2 && (cent->currentState.modelGhoul2 == G2_MODELPART_HEAD || cent->currentState.modelGhoul2 == G2_MODELPART_WAIST))
		{ //dismember settings are not high enough to display decaps and torso slashes
			return;
		}

		if (!cent->ghoul2)
		{
			const char *limbBone;
			const char *rotateBone;
			char	limbName[MAX_QPATH];
			char	stubName[MAX_QPATH];
			char	limbCapName[MAX_QPATH];
			char	stubCapName[MAX_QPATH];
			char *limbTagName;
			char *stubTagName;
			int limb_anim;
			int newBolt;
			int limbBit = (1 << (cent->currentState.modelGhoul2-10));

			if (clEnt && (clEnt->torsoBolt & limbBit))
			{ //already have this limb missing!
				return;
			}


			if (clEnt && !(clEnt->currentState.eFlags & EF_DEAD))
			{ //death flag hasn't made it through yet for the limb owner, we cannot create the limb until he's flagged as dead
				return;
			}

			if (clEnt && (!BG_InDeathAnim(clEnt->currentState.torsoAnim) || !BG_InDeathAnim(clEnt->pe.torso.animationNumber)))
			{ //don't make it unless we're in an actual death anim already
				if (clEnt->currentState.torsoAnim != BOTH_RIGHTHANDCHOPPEDOFF)
				{ //exception
					return;
				}
			}

			cent->bolt4 = -1;
			cent->trailTime = 0;

			if (cent->currentState.modelGhoul2 == G2_MODELPART_HEAD)
			{
				limbBone = "cervical";
				rotateBone = "cranium";
				Q_strncpyz( limbName , "head", sizeof( limbName  ) );
				Q_strncpyz( limbCapName, "head_cap_torso", sizeof( limbCapName ) );
				Q_strncpyz( stubCapName, "torso_cap_head", sizeof( stubCapName ) );
				limbTagName = "*head_cap_torso";
				stubTagName = "*torso_cap_head";
				limb_anim = BOTH_DISMEMBER_HEAD1;
			}
			else if (cent->currentState.modelGhoul2 == G2_MODELPART_WAIST)
			{
				limbBone = "pelvis";

				if (clEnt->localAnimIndex < NUM_RESERVED_ANIMSETS)
				{ //humanoid/rtrooper
					rotateBone = "thoracic";
				}
				else
				{
					rotateBone = "pelvis";
				}
				Q_strncpyz( limbName, "torso", sizeof( limbName ) );
				Q_strncpyz( limbCapName, "torso_cap_hips", sizeof( limbCapName ) );
				Q_strncpyz( stubCapName, "hips_cap_torso", sizeof( stubCapName ) );
				limbTagName = "*torso_cap_hips";
				stubTagName = "*hips_cap_torso";
				limb_anim = BOTH_DISMEMBER_TORSO1;
			}
			else if (cent->currentState.modelGhoul2 == G2_MODELPART_LARM)
			{
				limbBone = "lhumerus";
				rotateBone = "lradius";
				BG_GetRootSurfNameWithVariant( clEnt->ghoul2, "l_arm", limbName, sizeof(limbName) );
				BG_GetRootSurfNameWithVariant( clEnt->ghoul2, "torso", stubName, sizeof(stubName) );
				Com_sprintf( limbCapName, sizeof( limbCapName ), "%s_cap_torso", limbName );
				Com_sprintf( stubCapName, sizeof( stubCapName), "%s_cap_l_arm", stubName );
				limbTagName = "*l_arm_cap_torso";
				stubTagName = "*torso_cap_l_arm";
				limb_anim = BOTH_DISMEMBER_LARM;
			}
			else if (cent->currentState.modelGhoul2 == G2_MODELPART_RARM)
			{
				limbBone = "rhumerus";
				rotateBone = "rradius";
				BG_GetRootSurfNameWithVariant( clEnt->ghoul2, "r_arm", limbName, sizeof(limbName) );
				BG_GetRootSurfNameWithVariant( clEnt->ghoul2, "torso", stubName, sizeof(stubName) );
				Com_sprintf( limbCapName, sizeof( limbCapName ), "%s_cap_torso", limbName );
				Com_sprintf( stubCapName, sizeof( stubCapName), "%s_cap_r_arm", stubName );
				limbTagName = "*r_arm_cap_torso";
				stubTagName = "*torso_cap_r_arm";
				limb_anim = BOTH_DISMEMBER_RARM;
			}
			else if (cent->currentState.modelGhoul2 == G2_MODELPART_RHAND)
			{
				limbBone = "rradiusX";
				rotateBone = "rhand";
				BG_GetRootSurfNameWithVariant( clEnt->ghoul2, "r_hand", limbName, sizeof(limbName) );
				BG_GetRootSurfNameWithVariant( clEnt->ghoul2, "r_arm", stubName, sizeof(stubName) );
				Com_sprintf( limbCapName, sizeof( limbCapName ), "%s_cap_r_arm", limbName );
				Com_sprintf( stubCapName, sizeof( stubCapName), "%s_cap_r_hand", stubName );
				limbTagName = "*r_hand_cap_r_arm";
				stubTagName = "*r_arm_cap_r_hand";
				limb_anim = BOTH_DISMEMBER_RARM;
			}
			else if (cent->currentState.modelGhoul2 == G2_MODELPART_LLEG)
			{
				limbBone = "lfemurYZ";
				rotateBone = "ltibia";
				BG_GetRootSurfNameWithVariant( clEnt->ghoul2, "l_leg", limbName, sizeof(limbName) );
				BG_GetRootSurfNameWithVariant( clEnt->ghoul2, "hips", stubName, sizeof(stubName) );
				Com_sprintf( limbCapName, sizeof( limbCapName ), "%s_cap_hips", limbName );
				Com_sprintf( stubCapName, sizeof( stubCapName), "%s_cap_l_leg", stubName );
				limbTagName = "*l_leg_cap_hips";
				stubTagName = "*hips_cap_l_leg";
				limb_anim = BOTH_DISMEMBER_LLEG;
			}
			else if (cent->currentState.modelGhoul2 == G2_MODELPART_RLEG)
			{
				limbBone = "rfemurYZ";
				rotateBone = "rtibia";
				BG_GetRootSurfNameWithVariant( clEnt->ghoul2, "r_leg", limbName, sizeof(limbName) );
				BG_GetRootSurfNameWithVariant( clEnt->ghoul2, "hips", stubName, sizeof(stubName) );
				Com_sprintf( limbCapName, sizeof( limbCapName ), "%s_cap_hips", limbName );
				Com_sprintf( stubCapName, sizeof( stubCapName), "%s_cap_r_leg", stubName );
				limbTagName = "*r_leg_cap_hips";
				stubTagName = "*hips_cap_r_leg";
				limb_anim = BOTH_DISMEMBER_RLEG;
			}
			else
			{//umm... just default to the right leg, I guess (same as on server)
				limbBone = "rfemurYZ";
				rotateBone = "rtibia";
				BG_GetRootSurfNameWithVariant( clEnt->ghoul2, "r_leg", limbName, sizeof(limbName) );
				BG_GetRootSurfNameWithVariant( clEnt->ghoul2, "hips", stubName, sizeof(stubName) );
				Com_sprintf( limbCapName, sizeof( limbCapName ), "%s_cap_hips", limbName );
				Com_sprintf( stubCapName, sizeof( stubCapName), "%s_cap_r_leg", stubName );
				limbTagName = "*r_leg_cap_hips";
				stubTagName = "*hips_cap_r_leg";
				limb_anim = BOTH_DISMEMBER_RLEG;
			}

			if (clEnt && clEnt->ghoul2)
			{
				if (trap->G2API_HasGhoul2ModelOnIndex(&(clEnt->ghoul2), 2))
				{ //don't want to bother dealing with a second saber on limbs and stuff, just remove the thing
					trap->G2API_RemoveGhoul2Model(&(clEnt->ghoul2), 2);
				}

				if (trap->G2API_HasGhoul2ModelOnIndex(&(clEnt->ghoul2), 3))
				{ //turn off jetpack also I suppose
					trap->G2API_RemoveGhoul2Model(&(clEnt->ghoul2), 3);
				}

				if (clEnt->localAnimIndex < NUM_RESERVED_ANIMSETS)
				{ //humanoid
					trap->G2API_SetBoneAngles(clEnt->ghoul2, 0, "model_root", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 100, cg.time);
					trap->G2API_SetBoneAngles(clEnt->ghoul2, 0, "pelvis", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 0, cg.time); 
					trap->G2API_SetBoneAngles(clEnt->ghoul2, 0, "thoracic", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 0, cg.time); 
					trap->G2API_SetBoneAngles(clEnt->ghoul2, 0, "upper_lumbar", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 100, cg.time);
					trap->G2API_SetBoneAngles(clEnt->ghoul2, 0, "lower_lumbar", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 100, cg.time);
					trap->G2API_SetBoneAngles(clEnt->ghoul2, 0, "cranium", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_Z, NEGATIVE_Y, POSITIVE_X, cgs.gameModels, 100, cg.time);
					for (int i = 0; i < MAX_ARMOR; i++) {
						if (clEnt->currentState.armor[i]) {
							trap->G2API_SetBoneAngles(clEnt->ghoul2, 4 + i, "model_root", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 100, cg.time);
							trap->G2API_SetBoneAngles(clEnt->ghoul2, 4 + i, "pelvis", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 0, cg.time);
							trap->G2API_SetBoneAngles(clEnt->ghoul2, 4 + i, "thoracic", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 0, cg.time);
							trap->G2API_SetBoneAngles(clEnt->ghoul2, 4 + i, "upper_lumbar", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 100, cg.time);
							trap->G2API_SetBoneAngles(clEnt->ghoul2, 4 + i, "lower_lumbar", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 100, cg.time);
							trap->G2API_SetBoneAngles(clEnt->ghoul2, 4 + i, "cranium", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_Z, NEGATIVE_Y, POSITIVE_X, cgs.gameModels, 100, cg.time);
						}
					}
				}
				else
				{
					trap->G2API_SetBoneAngles(clEnt->ghoul2, 0, "model_root", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 100, cg.time);
					trap->G2API_SetBoneAngles(clEnt->ghoul2, 0, "pelvis", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 0, cg.time); 
					trap->G2API_SetBoneAngles(clEnt->ghoul2, 0, "upper_lumbar", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 100, cg.time);
					trap->G2API_SetBoneAngles(clEnt->ghoul2, 0, "lower_lumbar", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 100, cg.time);
				}

				trap->G2API_DuplicateGhoul2Instance(clEnt->ghoul2, &cent->ghoul2);
			}

			if (!cent->ghoul2)
			{
				return;
			}

			newBolt = trap->G2API_AddBolt( cent->ghoul2, 0, limbTagName );
			if ( newBolt != -1 )
			{
				vec3_t boltOrg, boltAng;

				trap->G2API_GetBoltMatrix(cent->ghoul2, 0, newBolt, &matrix, cent->lerpAngles, cent->lerpOrigin, cg.time, cgs.gameModels, cent->modelScale);

				BG_GiveMeVectorFromMatrix(&matrix, ORIGIN, boltOrg);
				BG_GiveMeVectorFromMatrix(&matrix, NEGATIVE_Y, boltAng);

				//trap->FX_PlayEffectID(cgs.effects.mBlasterSmoke, boltOrg, boltAng, -1, -1);
			}

			cent->bolt4 = newBolt;

			trap->G2API_SetRootSurface(cent->ghoul2, 0, limbName);

			trap->G2API_SetNewOrigin(cent->ghoul2, trap->G2API_AddBolt(cent->ghoul2, 0, rotateBone));

			trap->G2API_SetSurfaceOnOff(cent->ghoul2, limbCapName, 0);

			trap->G2API_SetSurfaceOnOff(clEnt->ghoul2, limbName, 0x00000100);
			trap->G2API_SetSurfaceOnOff(clEnt->ghoul2, stubCapName, 0);

			newBolt = trap->G2API_AddBolt( clEnt->ghoul2, 0, stubTagName );
			if ( newBolt != -1 )
			{
				vec3_t boltOrg, boltAng;

				trap->G2API_GetBoltMatrix(clEnt->ghoul2, 0, newBolt, &matrix, clEnt->lerpAngles, clEnt->lerpOrigin, cg.time, cgs.gameModels, clEnt->modelScale);

				BG_GiveMeVectorFromMatrix(&matrix, ORIGIN, boltOrg);
				BG_GiveMeVectorFromMatrix(&matrix, NEGATIVE_Y, boltAng);

				//trap->FX_PlayEffectID(cgs.effects.mBlasterSmoke, boltOrg, boltAng, -1, -1);
			}

			if (cent->currentState.modelGhoul2 == G2_MODELPART_RARM || cent->currentState.modelGhoul2 == G2_MODELPART_RHAND || cent->currentState.modelGhoul2 == G2_MODELPART_WAIST)
			{ //Cut his weapon holding arm off, so remove the weapon
				if (trap->G2API_HasGhoul2ModelOnIndex(&(clEnt->ghoul2), 1))
				{
					trap->G2API_RemoveGhoul2Model(&(clEnt->ghoul2), 1);
				}
			}

			clEnt->torsoBolt |= limbBit;

			VectorCopy(cent->lerpOrigin, cent->turAngles);
		}

		//Use origin smoothing since dismembered limbs use ExPhys
		if (DistanceSquared(cent->turAngles,cent->lerpOrigin)>18000.0f)
		{
			VectorCopy(cent->lerpOrigin, cent->turAngles);
		}

		VectorSubtract(cent->lerpOrigin, cent->turAngles, posDif);
		
		for (k=0;k<3;k++)
		{
			cent->turAngles[k]=(cent->turAngles[k]+posDif[k]*smoothFactor);
			cent->lerpOrigin[k]=cent->turAngles[k];
		}

		if (cent->ghoul2 && cent->bolt4 != -1 && cent->trailTime < cg.time)
		{
			if ( cent->bolt4 != -1 && 
				(cent->currentState.pos.trDelta[0] || cent->currentState.pos.trDelta[1] || cent->currentState.pos.trDelta[2]) )
			{
				vec3_t boltOrg, boltAng;

				trap->G2API_GetBoltMatrix(cent->ghoul2, 0, cent->bolt4, &matrix, cent->lerpAngles, cent->lerpOrigin, cg.time, cgs.gameModels, cent->modelScale);

				BG_GiveMeVectorFromMatrix(&matrix, ORIGIN, boltOrg);
				BG_GiveMeVectorFromMatrix(&matrix, NEGATIVE_Y, boltAng);

				if (!boltAng[0] && !boltAng[1] && !boltAng[2])
				{
					boltAng[1] = 1;
				}
				trap->FX_PlayEffectID(cgs.effects.mBlasterSmoke, boltOrg, boltAng, -1, -1, false);

				cent->trailTime = cg.time + 400;
			}
		}

		ent.radius = cent->currentState.g2radius;
		ent.hModel = 0;
	}

	if (cent->currentState.number >= MAX_CLIENTS &&
		cent->currentState.activeForcePass == NUM_FORCE_POWERS+1 )
	{
		vec3_t				empAngles;
		centity_t			*empOwn;

		empOwn = &cg_entities[cent->currentState.emplacedOwner];

		if (cg.snap->ps.clientNum == empOwn->currentState.number &&
			!cg.renderingThirdPerson)
		{
			VectorCopy(cg.refdef.viewangles, empAngles);
		}
		else
		{
			VectorCopy(empOwn->lerpAngles, empAngles);
		}

		if (empAngles[PITCH] > 40)
		{
			empAngles[PITCH] = 40;
		}
		empAngles[YAW] -= cent->currentState.angles[YAW];

		trap->G2API_SetBoneAngles( cent->ghoul2, 0, "Bone02", empAngles, BONE_ANGLES_REPLACE, NEGATIVE_Y, NEGATIVE_X, POSITIVE_Z, NULL, 0, cg.time); 
	}

	s1 = &cent->currentState;

	// if set to invisible, skip
	if ((!s1->modelindex) && !(trap->G2_HaveWeGhoul2Models(cent->ghoul2))) 
	{
		return;
	}

	if ( ( s1->eFlags & EF_NODRAW ) ) 
	{
		return;
	}

	// set frame
	if ( s1->eFlags & EF_SHADER_ANIM )
	{
		// Deliberately setting it up so that shader anim will completely override any kind of model animation frame setting.
		ent.renderfx|=RF_SETANIMINDEX;
		ent.skinNum = s1->frame;
	}
	else
	{
		ent.frame = s1->frame;
	}
	ent.oldframe = ent.frame;
	ent.backlerp = 0;
	
	VectorCopy( cent->lerpOrigin, ent.origin);
	VectorCopy( cent->lerpOrigin, ent.oldorigin);

	if (cent->currentState.modelGhoul2)
	{ //If the game says this guy uses a ghoul2 model and the g2 instance handle is null, then initialize it
		if (!cent->ghoul2 && !cent->currentState.bolt1)
		{
			char skinName[MAX_QPATH];
			const char *modelName = CG_ConfigString( CS_MODELS+cent->currentState.modelindex );
			int l;
			int skin = 0;

			trap->G2API_InitGhoul2Model(&cent->ghoul2, modelName, 0, 0, 0, 0, 0);
			if (cent->ghoul2 && trap->G2API_SkinlessModel(cent->ghoul2, 0))
			{ //well, you'd never want a skinless model, so try to get his skin...
				Q_strncpyz(skinName, modelName, MAX_QPATH);
				l = strlen(skinName) - 1;
				while (l > 0 && skinName[l] != '/')
				{ //parse back to first /
					l--;
				}
				if (skinName[l] == '/')
				{ //got it
					l++;
					skinName[l] = 0;
					Q_strcat(skinName, MAX_QPATH, "model_default.skin");
		
					skin = trap->R_RegisterSkin(skinName);
				}
				trap->G2API_SetSkin(cent->ghoul2, 0, skin, skin);
			}
		}
		else if (cent->currentState.bolt1)
		{
			TurretClientRun(cent);
		}

		if (cent->ghoul2)
		{ //give us a proper radius
		    doNotSetModel = qtrue;
			ent.radius = cent->currentState.g2radius;
		}
	}
	
/*
Ghoul2 Insert Start
*/
	CG_SetGhoul2Info(&ent, cent);

/*
Ghoul2 Insert End
*/

	if (s1->eType == ET_BODY)
	{ //bodies should have a radius as well
		ent.radius = cent->currentState.g2radius;

		if (cent->ghoul2)
		{ //all bodies should already have a ghoul2 instance. Use it to set the torso/head angles to 0.
			cent->lerpAngles[PITCH] = 0;
			cent->lerpAngles[ROLL] = 0;
			trap->G2API_SetBoneAngles(cent->ghoul2, 0, "pelvis", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 0, cg.time); 
			trap->G2API_SetBoneAngles(cent->ghoul2, 0, "thoracic", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 0, cg.time); 
			trap->G2API_SetBoneAngles(cent->ghoul2, 0, "upper_lumbar", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 100, cg.time);
			trap->G2API_SetBoneAngles(cent->ghoul2, 0, "lower_lumbar", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 100, cg.time);
			trap->G2API_SetBoneAngles(cent->ghoul2, 0, "cranium", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_Z, NEGATIVE_Y, POSITIVE_X, cgs.gameModels, 100, cg.time);

			for (i = 0; i < MAX_ARMOR; i++) {
				trap->G2API_SetBoneAngles(cent->ghoul2, 4+i, "pelvis", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 0, cg.time);
				trap->G2API_SetBoneAngles(cent->ghoul2, 4+i, "thoracic", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 0, cg.time);
				trap->G2API_SetBoneAngles(cent->ghoul2, 4+i, "upper_lumbar", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 100, cg.time);
				trap->G2API_SetBoneAngles(cent->ghoul2, 4+i, "lower_lumbar", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_X, NEGATIVE_Y, NEGATIVE_Z, cgs.gameModels, 100, cg.time);
				trap->G2API_SetBoneAngles(cent->ghoul2, 4+i, "cranium", vec3_origin, BONE_ANGLES_POSTMULT, POSITIVE_Z, NEGATIVE_Y, POSITIVE_X, cgs.gameModels, 100, cg.time);
			}
		}
	}

	if (!doNotSetModel)
	{
		ent.hModel = cgs.gameModels[s1->modelindex];
	}

	// player model
	if (s1->number == cg.snap->ps.clientNum) {
		ent.renderfx |= RF_THIRD_PERSON;	// only draw from mirrors
	}

	// convert angles to axis
	AnglesToAxis( cent->lerpAngles, ent.axis );

	if (cent->currentState.iModelScale)
	{ //if the server says we have a custom scale then set it now.
		cent->modelScale[0] = cent->modelScale[1] = cent->modelScale[2] = cent->currentState.iModelScale/100.0f;
		VectorCopy(cent->modelScale, ent.modelScale);
		ScaleModelAxis(&ent);
	}
	else
	{
		VectorClear(cent->modelScale);
	}

	if ( cent->currentState.time > cg.time && cent->currentState.weapon == WP_EMPLACED_GUN )
	{
		// make the gun pulse red to warn about it exploding
		val = (1.0f - (float)(cent->currentState.time - cg.time) / 3200.0f ) * 0.3f;

		ent.customShader = trap->R_RegisterShader( "gfx/effects/turretflashdie" );
		ent.shaderRGBA[0] = (sin( cg.time * 0.04f ) * val * 0.4f + val) * 255;
		ent.shaderRGBA[1] = ent.shaderRGBA[2] = 0;

		ent.shaderRGBA[3] = 100;
		trap->R_AddRefEntityToScene( &ent );
		ent.customShader = 0;
	}
	else if ( cent->currentState.time == -1 && cent->currentState.weapon == WP_EMPLACED_GUN)
	{
		ent.customShader = trap->R_RegisterShader( "models/map_objects/imp_mine/turret_chair_dmg.tga" );
		//trap->R_AddRefEntityToScene( &ent );
	}

	if ((cent->currentState.eFlags & EF_DISINTEGRATION) && cent->currentState.eType == ET_BODY)
	{
		if (!cent->dustTrailTime)
		{
			cent->dustTrailTime = cg.time;
		}

		CG_Disintegration(cent, &ent);
		return;
	}
	else if (cent->currentState.eType == ET_BODY)
	{
		if (cent->bodyFadeTime > cg.time)
		{
			qboolean lightSide = cent->teamPowerType;
			vec3_t hitLoc, tempAng;
			float tempLength;
			int curTimeDif = ((cg.time + 60000) - cent->bodyFadeTime);
			int tMult = curTimeDif*0.08f;

			ent.renderfx |= RF_FORCE_ENT_ALPHA;

			/*
			if (!cent->bodyHeight)
			{
				cent->bodyHeight = ent.origin[2];
			}
			*/

			if (curTimeDif*0.1f > 254)
			{
				ent.shaderRGBA[3] = 0;
			}
			else
			{
				ent.shaderRGBA[3] = (254 - tMult);
			}

			if (ent.shaderRGBA[3] >= 1)
			{ //add the transparent body section
				trap->R_AddRefEntityToScene (&ent);
			}

			ent.renderfx &= ~RF_FORCE_ENT_ALPHA;
			ent.renderfx |= RF_RGB_TINT;

			if (tMult > 200)
			{ //begin the disintegration effect
				ent.shaderRGBA[3] = 200;
				if (!cent->dustTrailTime)
				{
					cent->dustTrailTime = cg.time;
					if (lightSide)
					{
						trap->S_StartSound ( NULL, cent->currentState.number, CHAN_AUTO, trap->S_RegisterSound("sound/weapons/force/see.wav") );
					}
					else
					{
						trap->S_StartSound ( NULL, cent->currentState.number, CHAN_AUTO, trap->S_RegisterSound("sound/weapons/force/lightning") );
					}
				}
				ent.endTime = cent->dustTrailTime;
				ent.renderfx |= RF_DISINTEGRATE2;
			}
			else
			{ //set the alpha on the to-be-disintegrated layer
				ent.shaderRGBA[3] = tMult;
				if (ent.shaderRGBA[3] < 1)
				{
					ent.shaderRGBA[3] = 1;
				}
			}
			//Set everything up on the disint ref
			ent.shaderRGBA[0] = ent.shaderRGBA[1] = ent.shaderRGBA[2] = ent.shaderRGBA[3];
			VectorCopy(cent->lerpOrigin, hitLoc);

			VectorSubtract( hitLoc, ent.origin, ent.oldorigin );
			
			tempLength = VectorNormalize( ent.oldorigin );
			vectoangles( ent.oldorigin, tempAng );
			tempAng[YAW] -= cent->lerpAngles[YAW];
			AngleVectors( tempAng, ent.oldorigin, NULL, NULL );
			VectorScale( ent.oldorigin, tempLength, ent.oldorigin );

			if (lightSide)
			{ //might be temporary, dunno.
				ent.customShader = cgs.media.playerShieldDamage;
			}
			else
			{
				ent.customShader = cgs.media.redSaberGlowShader;
			}

			//slowly move the glowing part upward, out of the fading body
			/*
			cent->bodyHeight += 0.4f;
			ent.origin[2] = cent->bodyHeight;
			*/

			trap->R_AddRefEntityToScene( &ent );
			ent.renderfx &= ~RF_DISINTEGRATE2;
			ent.customShader = 0;

			if (curTimeDif < 3400)
			{
				if (lightSide)
				{
					if (curTimeDif < 2200)
					{ //probably temporary
						trap->S_StartSound ( NULL, cent->currentState.number, CHAN_AUTO, trap->S_RegisterSound( "sound/weapons/saber/saberhum1.wav" ) );
					}
				}
				else
				{ //probably temporary as well
					ent.renderfx |= RF_RGB_TINT;
					ent.shaderRGBA[0] = 255;
					ent.shaderRGBA[1] = ent.shaderRGBA[2] = 0;
					ent.shaderRGBA[3] = 255;
					if ( rand() & 1 )
					{
						ent.customShader = cgs.media.electricBodyShader;	
					}
					else
					{
						ent.customShader = cgs.media.electricBody2Shader;
					}
					if ( random() > 0.9f )
					{
						trap->S_StartSound ( NULL, cent->currentState.number, CHAN_AUTO, cgs.media.crackleSound );
					}
					trap->R_AddRefEntityToScene( &ent );
				}
			}

			return;
		}
		else
		{
			cent->dustTrailTime = 0;
		}
	}

	if (cent->currentState.modelGhoul2 &&
		!ent.ghoul2 &&
		!ent.hModel)
	{
		return;
	}

	if ( cent->currentState.time == -1 && cent->currentState.weapon == WP_TRIP_MINE && cent->currentState.bolt2 == 1)
	{ //Makes prox mines cloaked	
		if (cent->currentState.eFlags & EF_FIRING) {
			ent.renderfx &= ~RF_FORCE_ENT_ALPHA;
			ent.renderfx |= RF_RGB_TINT;
			ent.shaderRGBA[0] = ent.shaderRGBA[1] = ent.shaderRGBA[2] = 255.0f;
			ent.shaderRGBA[3] = 0;
			ent.customShader = cgs.media.cloakedShader;
			trap->R_AddRefEntityToScene( &ent );
		} else {
			// Show the normal one
			trap->R_AddRefEntityToScene (&ent);
			// AND the cloak one over it
			ent.renderfx &= ~RF_FORCE_ENT_ALPHA;
			ent.renderfx |= RF_RGB_TINT;
			ent.shaderRGBA[0] = ent.shaderRGBA[1] = ent.shaderRGBA[2] = 255.0f;
			ent.shaderRGBA[3] = 0;
			ent.customShader = cgs.media.cloakedShader;
			trap->R_AddRefEntityToScene( &ent );
		}
	} else {
		// add to refresh list
		if ( ent.hModel > 0 || ent.ghoul2 != NULL || ent.customShader != NULL_HANDLE )
		{
			trap->R_AddRefEntityToScene (&ent);
		}
	}

	if (cent->bolt3 == 999)
	{ //this is an in-flight saber being rendered manually
		vec3_t org;
		float wv;
		int i;
		addspriteArgStruct_t fxSArgs;
		//refEntity_t sRef;
		//memcpy( &sRef, &ent, sizeof( sRef ) );

		ent.customShader = cgs.media.solidWhite;
		ent.renderfx = RF_RGB_TINT;
		wv = sin( cg.time * 0.003f ) * 0.08f + 0.1f;
		ent.shaderRGBA[0] = wv * 255;
		ent.shaderRGBA[1] = wv * 255;
		ent.shaderRGBA[2] = wv * 0;
		trap->R_AddRefEntityToScene (&ent);

		for ( i = -4; i < 10; i += 1 )
		{
			VectorMA( ent.origin, -i, ent.axis[2], org );

			VectorCopy(org, fxSArgs.origin);
			VectorClear(fxSArgs.vel);
			VectorClear(fxSArgs.accel);
			fxSArgs.scale = 5.5f;
			fxSArgs.dscale = 5.5f;
			fxSArgs.sAlpha = wv;
			fxSArgs.eAlpha = wv;
			fxSArgs.rotation = 0.0f;
			fxSArgs.bounce = 0.0f;
			fxSArgs.life = 1.0f;
			fxSArgs.shader = cgs.media.yellowDroppedSaberShader;
			fxSArgs.flags = 0x08000000;

			//trap->FX_AddSprite( org, NULL, NULL, 5.5f, 5.5f, wv, wv, 0.0f, 0.0f, 1.0f, cgs.media.yellowSaberGlowShader, 0x08000000 );
			trap->FX_AddSprite(&fxSArgs);
		}
	}
	else if (cent->currentState.trickedentindex3)
	{ //holocron special effects
		vec3_t org;
		float wv;
		addspriteArgStruct_t fxSArgs;
		//refEntity_t sRef;
		//memcpy( &sRef, &ent, sizeof( sRef ) );

		ent.customShader = cgs.media.solidWhite;
		ent.renderfx = RF_RGB_TINT;
		wv = sin( cg.time * 0.005f ) * 0.08f + 0.1f; //* 0.08f + 0.1f;

		if (cent->currentState.trickedentindex3 == 1)
		{ //dark
			ent.shaderRGBA[0] = wv*255;
			ent.shaderRGBA[1] = 0;
			ent.shaderRGBA[2] = 0;
		}
		else if (cent->currentState.trickedentindex3 == 2)
		{ //light
			ent.shaderRGBA[0] = wv*255;
			ent.shaderRGBA[1] = wv*255;
			ent.shaderRGBA[2] = wv*255;
		}
		else
		{ //neutral
			if ((s1->modelindex+128) == FP_SABER_OFFENSE ||
				(s1->modelindex+128) == FP_SABER_DEFENSE ||
				(s1->modelindex+128) == FP_SABERTHROW)
			{ //saber power
				ent.shaderRGBA[0] = 0;
				ent.shaderRGBA[1] = wv*255;
				ent.shaderRGBA[2] = 0;
			}
			else
			{
				ent.shaderRGBA[0] = 0;
				ent.shaderRGBA[1] = wv*255;
				ent.shaderRGBA[2] = wv*255;
			}
		}

		ent.modelScale[0] = 1.1f;
		ent.modelScale[1] = 1.1f;
		ent.modelScale[2] = 1.1f;

		ent.origin[2] -= 2;
		ScaleModelAxis(&ent);

		trap->R_AddRefEntityToScene (&ent);
		
		VectorMA( ent.origin, 1, ent.axis[2], org );

		org[2] += 18;

		wv = sin( cg.time * 0.002f ) * 0.08f + 0.1f; //* 0.08f + 0.1f;

		VectorCopy(org, fxSArgs.origin);
		VectorClear(fxSArgs.vel);
		VectorClear(fxSArgs.accel);
		fxSArgs.scale = wv*120;//16.0f;
		fxSArgs.dscale = wv*120;//16.0f;
		fxSArgs.sAlpha = wv*12;
		fxSArgs.eAlpha = wv*12;
		fxSArgs.rotation = 0.0f;
		fxSArgs.bounce = 0.0f;
		fxSArgs.life = 1.0f;

		fxSArgs.flags = 0x08000000|0x00000001;

		if (cent->currentState.trickedentindex3 == 1)
		{ //dark
			fxSArgs.sAlpha *= 3;
			fxSArgs.eAlpha *= 3;
			fxSArgs.shader = cgs.media.redSaberGlowShader;
			trap->FX_AddSprite(&fxSArgs);
		}
		else if (cent->currentState.trickedentindex3 == 2)
		{ //light
			fxSArgs.sAlpha *= 1.5f;
			fxSArgs.eAlpha *= 1.5f;
			fxSArgs.shader = cgs.media.redSaberGlowShader;
			trap->FX_AddSprite(&fxSArgs);
			fxSArgs.shader = cgs.media.greenSaberGlowShader;
			trap->FX_AddSprite(&fxSArgs);
			fxSArgs.shader = cgs.media.blueSaberGlowShader;
			trap->FX_AddSprite(&fxSArgs);
		}
		else
		{ //neutral
			if ((s1->modelindex+128) == FP_SABER_OFFENSE ||
				(s1->modelindex+128) == FP_SABER_DEFENSE ||
				(s1->modelindex+128) == FP_SABERTHROW)
			{ //saber power
				fxSArgs.sAlpha *= 1.5f;
				fxSArgs.eAlpha *= 1.5f;
				fxSArgs.shader = cgs.media.greenSaberGlowShader;
				trap->FX_AddSprite(&fxSArgs);
			}
			else
			{
				fxSArgs.sAlpha *= 0.5f;
				fxSArgs.eAlpha *= 0.5f;
				fxSArgs.shader = cgs.media.greenSaberGlowShader;
				trap->FX_AddSprite(&fxSArgs);
				fxSArgs.shader = cgs.media.blueSaberGlowShader;
				trap->FX_AddSprite(&fxSArgs);
			}
		}
	}

	if ( cent->currentState.time == -1 && cent->currentState.weapon == WP_TRIP_MINE && (cent->currentState.eFlags & EF_FIRING))
	{ //if force sight is active, render the laser multiple times up to the force sight level to increase visibility
		if (cent->currentState.owner != cg.snap->ps.clientNum && !TeamFriendly( cent->currentState.owner ) && !(cg.snap->ps.fd.forcePowersActive & (1 << FP_SEE))) {
			// Dont render them
		} else {
			if ((cg.time >> 10 & 1) && TeamFriendly( cent->currentState.owner ) && cent->currentState.owner != cg.snap->ps.clientNum) {
				// Dont render (blinking)
			} else {
				if (cent->currentState.bolt2 == 1)
				{
					VectorMA( ent.origin, 6.6f, ent.axis[0], beamOrg );// forward
					beamID = cgs.effects.tripmineGlowFX;
					trap->FX_PlayEffectID( beamID, beamOrg, cent->currentState.pos.trDelta, -1, -1, false );
				}
				else
				{
					int i = 0;

					VectorMA( ent.origin, 6.6f, ent.axis[0], beamOrg );// forward
					beamID = cgs.effects.tripmineLaserFX;

					if (cg.snap->ps.fd.forcePowersActive & (1 << FP_SEE))
					{
						i = cg.snap->ps.fd.forcePowerLevel[FP_SEE];

						while (i > 0)
						{
							trap->FX_PlayEffectID( beamID, beamOrg, cent->currentState.pos.trDelta, -1, -1, false );
							trap->FX_PlayEffectID( beamID, beamOrg, cent->currentState.pos.trDelta, -1, -1, false );
							i--;
						}
					}

					trap->FX_PlayEffectID( beamID, beamOrg, cent->currentState.pos.trDelta, -1, -1, false );
				}
			}
		}
	}
}

/*
==================
CG_Speaker

Speaker entities can automatically play sounds
==================
*/
static void CG_Speaker( centity_t *cent ) {
	if (cent->currentState.trickedentindex)
	{
		CG_S_StopLoopingSound(cent->currentState.number, -1);
	}

	if ( ! cent->currentState.clientNum ) {	// FIXME: use something other than clientNum...
		return;		// not auto triggering
	}

	if ( cg.time < cent->miscTime ) {
		return;
	}

	trap->S_StartSound (NULL, cent->currentState.number, CHAN_ITEM, cgs.gameSounds[cent->currentState.eventParm] );

	//	ent->s.frame = ent->wait * 10;
	//	ent->s.clientNum = ent->random * 10;
	cent->miscTime = cg.time + cent->currentState.frame * 100 + cent->currentState.clientNum * 100 * crandom();
}

/*
==================
CG_Item
==================
*/
static void CG_Item( centity_t *cent ) {
	refEntity_t		ent;
	entityState_t	*es;
	gitem_t			*item;
	int				msec;
	float			scale;
	weaponInfo_t	*wi;

	es = &cent->currentState;
	if ( es->modelindex >= bg_numItems ) {
		trap->Error( ERR_DROP, "Bad item index %i on entity", es->modelindex );
	}

/*
Ghoul2 Insert Start
*/

	if ((es->eFlags & EF_NODRAW) && (es->eFlags & EF_ITEMPLACEHOLDER))
	{
		es->eFlags &= ~EF_NODRAW;
	}

	if ( !es->modelindex ) 
	{
		return;
	}

	item = &bg_itemlist[ es->modelindex ];

	if ((item->giType == IT_WEAPON || item->giType == IT_POWERUP) &&
		!(cent->currentState.eFlags & EF_DROPPEDWEAPON) &&
		!cg_simpleItems.integer)
	{
		vec3_t uNorm = { 0.0f, 0.0f, 1.0f };

		memset( &ent, 0, sizeof( ent ) );

		ent.customShader = 0;
		VectorCopy(cent->lerpOrigin, ent.origin);
		VectorCopy( cent->currentState.angles, cent->lerpAngles );
		AnglesToAxis(cent->lerpAngles, ent.axis);
		ent.hModel = cgs.media.itemHoloModel;

		trap->R_AddRefEntityToScene(&ent);

		trap->FX_PlayEffectID(cgs.effects.itemCone, ent.origin, uNorm, -1, -1, false);
	}

	// if set to invisible, skip
	if ( ( es->eFlags & EF_NODRAW ) ) 
	{
		return;
	}
/*
Ghoul2 Insert End
*/

	if ( cg_simpleItems.integer && item->giType != IT_TEAM ) {
		memset( &ent, 0, sizeof( ent ) );
		ent.reType = RT_SPRITE;
		VectorCopy( cent->lerpOrigin, ent.origin );
		ent.radius = 14;
		ent.customShader = cg_items[es->modelindex].icon;
		ent.shaderRGBA[0] = 255;
		ent.shaderRGBA[1] = 255;
		ent.shaderRGBA[2] = 255;

		ent.origin[2] += 16;

		if ( es->eFlags & EF_ITEMPLACEHOLDER )
		{
			ent.shaderRGBA[0] = 200;
			ent.shaderRGBA[1] = 200;
			ent.shaderRGBA[2] = 200;
			ent.shaderRGBA[3] = 150 + sin(cg.time*0.01f)*30;
		}
		else
		{
			ent.shaderRGBA[3] = 255;
		}

		trap->R_AddRefEntityToScene(&ent);
		return;
	}

	if ((item->giType == IT_WEAPON || item->giType == IT_POWERUP) &&
		!(cent->currentState.eFlags & EF_DROPPEDWEAPON))
	{
		cent->lerpOrigin[2] += 16;
	}

	if ((!(cent->currentState.eFlags & EF_DROPPEDWEAPON) || item->giType == IT_POWERUP) &&
		(item->giType == IT_WEAPON || item->giType == IT_POWERUP))
	{
		// items bob up and down continuously
		scale = 0.005f + cent->currentState.number * 0.00001f;
		cent->lerpOrigin[2] += 4 + cos( ( cg.time + 1000 ) *  scale ) * 4;
	}
	else
	{
		if (item->giType == IT_HEALTH)
		{
			cent->lerpOrigin[2] += 2;
		}
		if (item->giType == IT_ARMOR)
		{
			if (item->quantity == 100)
			{
				cent->lerpOrigin[2] += 7;
			}
		}
	}

	memset (&ent, 0, sizeof(ent));

	if ( (!(cent->currentState.eFlags & EF_DROPPEDWEAPON) || item->giType == IT_POWERUP) &&
		(item->giType == IT_WEAPON || item->giType == IT_POWERUP) )
	{ //only weapons and powerups rotate now
		// autorotate at one of two speeds
		VectorCopy( cg.autoAngles, cent->lerpAngles );
		AxisCopy( cg.autoAxis, ent.axis );
	}
	else
	{
		VectorCopy( cent->currentState.angles, cent->lerpAngles );
		AnglesToAxis(cent->lerpAngles, ent.axis);
	}

	wi = NULL;
	// the weapons have their origin where they attatch to player
	// models, so we need to offset them or they will rotate
	// eccentricly
	if (!(cent->currentState.eFlags & EF_DROPPEDWEAPON))
	{
		if ( item->giType == IT_WEAPON ) {
			wi = CG_WeaponInfo (item->giTag, cent->currentState.weaponVariation);
			cent->lerpOrigin[0] -= 
				wi->weaponMidpoint[0] * ent.axis[0][0] +
				wi->weaponMidpoint[1] * ent.axis[1][0] +
				wi->weaponMidpoint[2] * ent.axis[2][0];
			cent->lerpOrigin[1] -= 
				wi->weaponMidpoint[0] * ent.axis[0][1] +
				wi->weaponMidpoint[1] * ent.axis[1][1] +
				wi->weaponMidpoint[2] * ent.axis[2][1];
			cent->lerpOrigin[2] -= 
				wi->weaponMidpoint[0] * ent.axis[0][2] +
				wi->weaponMidpoint[1] * ent.axis[1][2] +
				wi->weaponMidpoint[2] * ent.axis[2][2];

			cent->lerpOrigin[2] += 8;	// an extra height boost
		}
	}
	else
	{
		wi = CG_WeaponInfo (item->giTag, cent->currentState.weaponVariation);

		// TODO: fix -.-
		switch(item->giTag)
		{
		case WP_BLASTER:
			cent->lerpOrigin[2] -= 12;
			break;
		case WP_DISRUPTOR:
			cent->lerpOrigin[2] -= 13;
			break;
		case WP_BOWCASTER:
			cent->lerpOrigin[2] -= 16;
			break;
		case WP_REPEATER:
			cent->lerpOrigin[2] -= 12;
			break;
		case WP_DEMP2:
			cent->lerpOrigin[2] -= 10;
			break;
		case WP_FLECHETTE:
			cent->lerpOrigin[2] -= 6;
			break;
		case WP_ROCKET_LAUNCHER:
			cent->lerpOrigin[2] -= 11;
			break;
		case WP_THERMAL:
			cent->lerpOrigin[2] -= 12;
			break;
		case WP_TRIP_MINE:
			cent->lerpOrigin[2] -= 16;
			break;
		case WP_DET_PACK:
			cent->lerpOrigin[2] -= 16;
			break;
		default:
			cent->lerpOrigin[2] -= 8;
			break;
		}
	}

	ent.hModel = cg_items[es->modelindex].models[0];
/*
Ghoul2 Insert Start
*/
	ent.ghoul2 = cg_items[es->modelindex].g2Models[0];
	ent.radius = cg_items[es->modelindex].radius[0];
	
	if ( item->giType == IT_WEAPON )
	{
	    ent.hModel = 0;
	    ent.ghoul2 = wi->g2WorldModel;
	}
	
	VectorCopy (cent->lerpAngles, ent.angles);
/*
Ghoul2 Insert End
*/
	VectorCopy( cent->lerpOrigin, ent.origin);
	VectorCopy( cent->lerpOrigin, ent.oldorigin);

	ent.nonNormalizedAxes = qfalse;

	// if just respawned, slowly scale up
	
	msec = cg.time - cent->miscTime;

	if ( es->eFlags & EF_ITEMPLACEHOLDER )		// item has been picked up
	{
		if ( es->eFlags & EF_DEAD )				// if item had been droped, don't show at all
			return;

		ent.renderfx |= RF_RGB_TINT;
		ent.shaderRGBA[0] = 0;
		ent.shaderRGBA[1] = 200;
		ent.shaderRGBA[2] = 85;
		ent.customShader = cgs.media.itemRespawningPlaceholder;
	}

	// increase the size of the weapons when they are presented as items
	if ( item->giType == IT_WEAPON ) {
		VectorScale( ent.axis[0], 1.5f, ent.axis[0] );
		VectorScale( ent.axis[1], 1.5f, ent.axis[1] );
		VectorScale( ent.axis[2], 1.5f, ent.axis[2] );
		ent.nonNormalizedAxes = qtrue;
		//trap->S_AddLoopingSound( cent->currentState.number, cent->lerpOrigin, vec3_origin, cgs.media.weaponHoverSound );
	}

	if (!(cent->currentState.eFlags & EF_DROPPEDWEAPON) &&
		(item->giType == IT_WEAPON || item->giType == IT_POWERUP))
	{
		ent.renderfx |= RF_MINLIGHT;
	}

	if (item->giType != IT_TEAM && msec >= 0 && msec < ITEM_SCALEUP_TIME && !(es->eFlags & EF_ITEMPLACEHOLDER) && !(es->eFlags & EF_DROPPEDWEAPON)) 
	{	// if just respawned, fade in, but don't do this for flags.
		float alpha;
		int a;
		
		alpha = (float)msec / ITEM_SCALEUP_TIME;
		a = alpha * 255.0f;
		if (a <= 0)
			a=1;

		ent.shaderRGBA[3] = a;
		if (item->giType != IT_POWERUP)
		{ //boon model uses a different blending mode for the sprite inside and doesn't look proper with this method
			ent.renderfx |= RF_FORCE_ENT_ALPHA;
		}
		trap->R_AddRefEntityToScene(&ent);
		
		ent.renderfx &= ~RF_FORCE_ENT_ALPHA;
	
		// Now draw the static shader over it.
		// Alpha in over half the time, out over half.
		
		a = alpha * 255.0f;

		a = 255 - a;

		if (a <= 0)
			a=1;
		if (a > 255)
			a=255;

		ent.customShader = cgs.media.itemRespawningRezOut;

		ent.renderfx |= RF_RGB_TINT;
		ent.shaderRGBA[0] = 0;
		ent.shaderRGBA[1] = 200;
		ent.shaderRGBA[2] = 85;

		trap->R_AddRefEntityToScene( &ent );
	}
	else
	{	// add to refresh list  -- normal item
		if (item->giType == IT_TEAM &&
			(item->giTag == PW_REDFLAG || item->giTag == PW_BLUEFLAG))
		{
			ent.modelScale[0] = 0.7f;
			ent.modelScale[1] = 0.7f;
			ent.modelScale[2] = 0.7f;
			ScaleModelAxis(&ent);
		}
		trap->R_AddRefEntityToScene(&ent);
	}

	// accompanying rings / spheres for powerups
	if ( !cg_simpleItems.integer ) 
	{
		vec3_t spinAngles;

		VectorClear( spinAngles );

		if ( item->giType == IT_HEALTH || item->giType == IT_POWERUP )
		{
			if ( ( ent.hModel = cg_items[es->modelindex].models[1] ) != 0 )
			{
				if ( item->giType == IT_POWERUP )
				{
					ent.origin[2] += 12;
					spinAngles[1] = ( cg.time & 1023 ) * 360 / -1024.0f;
				}
				AnglesToAxis( spinAngles, ent.axis );
				
				trap->R_AddRefEntityToScene( &ent );
			}
		}
	}
}

//============================================================================

void CG_CreateDistortionTrailPart(centity_t *cent, float scale, vec3_t pos)
{
	refEntity_t ent;
	vec3_t ang;
	float vLen;

	if (!cg_renderToTextureFX.integer)
	{
		return;
	}
	memset( &ent, 0, sizeof( ent ) );

	VectorCopy( pos, ent.origin );

	VectorSubtract(ent.origin, cg.refdef.vieworg, ent.axis[0]);
	vLen = VectorLength(ent.axis[0]);
	if (VectorNormalize(ent.axis[0]) <= 0.1f)
	{	// Entity is right on vieworg.  quit.
		return;
	}

	VectorCopy(cent->lerpAngles, ang);
	ang[PITCH] += 90.0f;
	AnglesToAxis(ang, ent.axis);

	//radius must be a power of 2, and is the actual captured texture size
	if (vLen < 512)
	{
		ent.radius = 256;
	}
	else if (vLen < 1024)
	{
		ent.radius = 128;
	}
	else if (vLen < 2048)
	{
		ent.radius = 64;
	}
	else
	{
		ent.radius = 32;
	}

	ent.modelScale[0] = scale;
	ent.modelScale[1] = scale;
	ent.modelScale[2] = scale*16.0f;
	ScaleModelAxis(&ent);

	ent.hModel = trap->R_RegisterModel("models/weapons2/merr_sonn/trailmodel.md3");
	ent.customShader = cgs.media.itemRespawningRezOut;//cgs.media.cloakedShader;//cgs.media.halfShieldShader;	

	ent.renderfx = (RF_DISTORTION|RF_FORCE_ENT_ALPHA);
	ent.shaderRGBA[0] = 255.0f;
	ent.shaderRGBA[1] = 255.0f;
	ent.shaderRGBA[2] = 255.0f;
	ent.shaderRGBA[3] = 100.0f;

	trap->R_AddRefEntityToScene( &ent );
}

/*
===============
CG_Missile
===============
*/
static void CG_Missile( centity_t *cent ) {
	refEntity_t			ent;
	entityState_t		*s1;
	const weaponInfo_t		*weapon;
//	int	col;

	s1 = &cent->currentState;

	/* JKG - Calculate the maximum travel distance for this weapon and free when reached */
	if ( 0 )
	{
		vec3_t	origin, difference;
		int		iLen;

		/* Calculate the distance we have traveled at this point in time */
		BG_EvaluateTrajectory( &cent->currentState.pos, cg.time, origin );
		VectorSubtract( origin, cent->currentState.pos.trBase, difference );
		iLen = ( int ) VectorLength( difference );

		/* Check to see if we have a range and to see if we have exceeded it */
		if ( s1->apos.trBase[0] && iLen >= s1->apos.trBase[0] )
		{
			if ( s1->time == cent->bolt1 )
			{
				return;
			}
			else
			{
				vec3_t /*dir, */fwd, org;
				
				/* Calculate the real position of this bolt */
				AngleVectors( s1->angles, fwd, NULL, NULL );
				VectorMA( s1->pos.trBase, s1->apos.trBase[0], fwd, org );

				/* Do the predicted weapon death in-air */
				JKG_RenderProjectileDeath (cent, org, fwd, s1->firingMode);

				/* Mark this guy as performed, we don't need another effect */
				cent->bolt1 = s1->time;
				return;
			}
		}
	}

	if ( s1->weapon > WP_NUM_WEAPONS && s1->weapon != G2_MODEL_PART ) {
		s1->weapon = 0;
		s1->weaponVariation = 0;
	}

	if (cent->ghoul2 && s1->weapon == G2_MODEL_PART)
	{
		weapon = CG_WeaponInfo (WP_SABER, s1->weaponVariation);
	}
	else
	{
		weapon = CG_WeaponInfo (s1->weapon, s1->weaponVariation);
	}

	if (cent->currentState.eFlags & EF_RADAROBJECT)
	{
		CG_AddRadarEnt(cent);
	}

	if (s1->weapon == WP_SABER)
	{
		if ((cent->currentState.modelindex != cent->serverSaberHitIndex || !cent->ghoul2) && !(s1->eFlags & EF_NODRAW))
		{ //no g2, or server changed the model we are using
			const char *saberModel = CG_ConfigString( CS_MODELS+cent->currentState.modelindex );

			cent->serverSaberHitIndex = cent->currentState.modelindex;

			if (cent->ghoul2)
			{ //clean if we already have one (because server changed model string index)
				trap->G2API_CleanGhoul2Models(&(cent->ghoul2));
				cent->ghoul2 = 0;
			}

			if (saberModel && saberModel[0])
			{
				trap->G2API_InitGhoul2Model(&cent->ghoul2, saberModel, 0, 0, 0, 0, 0);
			}
			else
			{
				trap->G2API_InitGhoul2Model(&cent->ghoul2, "models/weapons2/saber/saber_w.glm", 0, 0, 0, 0, 0);
			}
			return;
		}
		else if (s1->eFlags & EF_NODRAW)
		{
			return;
		}
	}

	if (cent->ghoul2)
	{ //give us a proper radius
		ent.radius = cent->currentState.g2radius;
	}

	// calculate the axis
	VectorCopy( s1->angles, cent->lerpAngles);

    if ( s1->weapon != WP_SABER )
    {
		JKG_RenderProjectile (cent, s1->firingMode);
        return;
    }

	// create the render entity
	memset (&ent, 0, sizeof(ent));
	VectorCopy( cent->lerpOrigin, ent.origin);
	VectorCopy( cent->lerpOrigin, ent.oldorigin);
/*
Ghoul2 Insert Start
*/
	CG_SetGhoul2Info(&ent, cent);  

/*
Ghoul2 Insert End
*/

	// flicker between two skins
	ent.skinNum = cg.clientFrame & 1;
	ent.renderfx = /*weapon->missileRenderfx | */RF_NOSHADOW;

	if ( !(s1->eFlags&EF_JETPACK_ACTIVE) )
	{
		if (s1->weapon != WP_SABER && s1->weapon != G2_MODEL_PART)
		{
			//if ( cent->currentState.eFlags | EF_ALT_FIRING )
			//rww - why was this like this?
			if ( cent->currentState.eFlags & EF_ALT_FIRING )
			{
				ent.hModel = weapon->altMissileModel;
			}
			else
			{
				ent.hModel = weapon->missileModel;
			}
		}
	}
	//add custom model
	else
	{
		return;
	}

	// spin as it moves
	if ( s1->apos.trType != TR_INTERPOLATE )
	{
		// convert direction of travel into axis
		if ( VectorNormalize2( s1->pos.trDelta, ent.axis[0] ) == 0 ) {
			ent.axis[0][2] = 1;
		}

		// spin as it moves
		if ( s1->pos.trType != TR_STATIONARY ) 
		{
			if ( s1->eFlags & EF_MISSILE_STICK )
			{
				RotateAroundDirection( ent.axis, cg.time * 0.5f );//Did this so regular missiles don't get broken
			}
			else
			{
				RotateAroundDirection( ent.axis, cg.time * 0.25f );//JFM:FLOAT FIX
			}
		} 
		else 
		{
			if ( s1->eFlags & EF_MISSILE_STICK )
			{
				RotateAroundDirection( ent.axis, (float)s1->pos.trTime * 0.5f );
			}
			else
			{
				RotateAroundDirection( ent.axis, (float)s1->time );
			}
		}
	}
	else
	{
		AnglesToAxis( cent->lerpAngles, ent.axis );
	}

	if (s1->weapon == WP_SABER)
	{
		ent.radius = s1->g2radius;
	}

	// add to refresh list, possibly with quad glow
	CG_AddRefEntityWithPowerups( &ent, s1, TEAM_FREE );

	if ( s1->eFlags & EF_FIRING )
	{//special code for adding the beam to the attached tripwire mine
		vec3_t	beamOrg;

		VectorMA( ent.origin, 8, ent.axis[0], beamOrg );// forward
		trap->FX_PlayEffectID( cgs.effects.mTripMineLaser, beamOrg, ent.axis[0], -1, -1, false );
	}
}

int	CG_BMS_START = 0;
int	CG_BMS_MID = 1;
int	CG_BMS_END = 2;

/*
-------------------------
CG_PlayDoorLoopSound
-------------------------
*/

void CG_PlayDoorLoopSound( centity_t *cent )
{
	sfxHandle_t	sfx;
	const char *soundSet;
	vec3_t	origin;
	float	*v;

	if ( !cent->currentState.soundSetIndex )
	{
		return;
	}

	soundSet = CG_ConfigString( CS_AMBIENT_SET + cent->currentState.soundSetIndex );

	if (!soundSet || !soundSet[0])
	{
		return;
	}

	sfx = trap->AS_GetBModelSound( soundSet, CG_BMS_MID );

	if ( sfx == -1 )
	{
		return;
	}

	if (cent->currentState.eType == ET_MOVER) //shouldn't be in here otherwise, but just in case.
	{
		v = cgs.inlineModelMidpoints[ cent->currentState.modelindex ];
		VectorAdd( cent->lerpOrigin, v, origin );
	}
	else
	{
		VectorCopy(cent->lerpOrigin, origin);
	}

	//ent->s.loopSound = sfx;
	CG_S_AddRealLoopingSound(cent->currentState.number, origin, vec3_origin, sfx);
}

/*
-------------------------
CG_PlayDoorSound
-------------------------
*/

void CG_PlayDoorSound( centity_t *cent, int type )
{
	sfxHandle_t	sfx;
	const char *soundSet;

	if ( !cent->currentState.soundSetIndex )
	{
		return;
	}

	soundSet = CG_ConfigString( CS_AMBIENT_SET + cent->currentState.soundSetIndex );

	if (!soundSet || !soundSet[0])
	{
		return;
	}

	sfx = trap->AS_GetBModelSound( soundSet, type );

	if ( sfx == -1 )
	{
		return;
	}

	trap->S_StartSound( NULL, cent->currentState.number, CHAN_AUTO, sfx );
}

/*
===============
CG_Mover
===============
*/
static void CG_Mover( centity_t *cent ) {
	refEntity_t			ent;
	entityState_t		*s1;

	s1 = &cent->currentState;

	// create the render entity
	memset (&ent, 0, sizeof(ent));

	if (cent->currentState.eFlags & EF_RADAROBJECT)
	{
		CG_AddRadarEnt(cent);
	}

	VectorCopy( cent->lerpOrigin, ent.origin);
	VectorCopy( cent->lerpOrigin, ent.oldorigin);
	AnglesToAxis( cent->lerpAngles, ent.axis );

	ent.renderfx = RF_NOSHADOW;
/*
Ghoul2 Insert Start
*/

	CG_SetGhoul2Info(&ent, cent);  
/*
Ghoul2 Insert End
*/
	// flicker between two skins (FIXME?)
	ent.skinNum = ( cg.time >> 6 ) & 1;

	// get the model, either as a bmodel or a modelindex
	if ( s1->solid == SOLID_BMODEL ) 
	{
		ent.hModel = cgs.inlineDrawModel[s1->modelindex];
	} 
	else 
	{
		ent.hModel = cgs.gameModels[s1->modelindex];
	}

	if ( s1->eFlags & EF_SHADER_ANIM )
	{
		ent.renderfx|=RF_SETANIMINDEX;
		ent.skinNum = s1->frame;
		//ent.shaderTime = cg.time*0.001f - s1->frame/s1->time;//NOTE: s1->time is number of frames
	}

	// add to refresh list
	trap->R_AddRefEntityToScene(&ent);

	// add the secondary model
	if ( s1->modelindex2 && s1->modelindex2 < MAX_MODELS ) 
	{
		ent.skinNum = 0;
		if ( s1->solid == SOLID_BMODEL )
		{
			ent.hModel = cgs.inlineDrawModel[s1->modelindex2];
		}
		else
		{
			ent.hModel = cgs.gameModels[s1->modelindex2];
		}

		if (s1->iModelScale)
		{ //custom model2 scale
			ent.modelScale[0] = ent.modelScale[1] = ent.modelScale[2] = s1->iModelScale/100.0f;
			ScaleModelAxis(&ent);
		}
		trap->R_AddRefEntityToScene(&ent);
	}

}

/*
===============
CG_Beam

Also called as an event
===============
*/
void CG_Beam( centity_t *cent ) {
	refEntity_t			ent;
	entityState_t		*s1;

	s1 = &cent->currentState;

	// create the render entity
	memset (&ent, 0, sizeof(ent));
	VectorCopy( s1->pos.trBase, ent.origin );
	VectorCopy( s1->origin2, ent.oldorigin );
	AxisClear( ent.axis );
	ent.reType = RT_BEAM;

	ent.renderfx = RF_NOSHADOW;
/*
Ghoul2 Insert Start
*/
	CG_SetGhoul2Info(&ent, cent);  

/*
Ghoul2 Insert End
*/
	// add to refresh list
	trap->R_AddRefEntityToScene(&ent);
}


/*
===============
CG_Portal
===============
*/
static void CG_Portal( centity_t *cent ) {
	refEntity_t			ent;
	entityState_t		*s1;

	s1 = &cent->currentState;

	// create the render entity
	memset (&ent, 0, sizeof(ent));
	VectorCopy( cent->lerpOrigin, ent.origin );
	VectorCopy( s1->origin2, ent.oldorigin );
	ByteToDir( s1->eventParm, ent.axis[0] );
	PerpendicularVector( ent.axis[1], ent.axis[0] );

	// negating this tends to get the directions like they want
	// we really should have a camera roll value
	VectorSubtract( vec3_origin, ent.axis[1], ent.axis[1] );

	CrossProduct( ent.axis[0], ent.axis[1], ent.axis[2] );
	ent.reType = RT_PORTALSURFACE;
	ent.oldframe = s1->powerups;
	ent.frame = s1->frame;		// rotation speed
	ent.skinNum = s1->clientNum/256.0f * 360;	// roll offset
/*
Ghoul2 Insert Start
*/
	CG_SetGhoul2Info(&ent, cent);  
/*
Ghoul2 Insert End
*/
	// add to refresh list
	trap->R_AddRefEntityToScene(&ent);
}


/*
===============
CG_Flag
===============
*/

int capture_start_time = 0;
qboolean flags_registerred = qfalse;

#ifndef TEAM_NONE
#define TEAM_NONE 0
#endif

// Warzone Flags...
static void CG_Flag( centity_t *cent ) {
	refEntity_t flagmodel;
	centity_t	*capturingflagent = &cg_entities[cg_entities[cg.clientNum].playerState->stats[STAT_CAPTURE_ENTITYNUM]];
	int			capture_ent_num = cg_entities[cg.clientNum].playerState->stats[STAT_CAPTURE_ENTITYNUM];

//	if (!cent->isRagging)
//	{// Use this to mark which flags have been added to radar...
		CG_AddRadarEnt(cent);
//		cent->isRagging = qtrue;
//	}

	if ( capture_ent_num != 0 && capture_ent_num == cent->currentState.number)
	{
		if (Distance(cent->lerpOrigin, cg_entities[cg.clientNum].lerpOrigin) <= cent->currentState.otherEntityNum2)
		{
			if (cent->currentState.teamowner == TEAM_NONE)
				cg.captureFlagPercent = cent->currentState.time2*2;
			else
				cg.captureFlagPercent = cent->currentState.time2;

			cg.capturingFlag = qtrue;
			capture_start_time = cg.time;
				
			if (cent->currentState.teamowner == cg_entities[cg.clientNum].currentState.teamowner
				&& cent->currentState.teamowner != TEAM_NONE)
				cg.recaptureingFlag = qtrue;
			else
				cg.recaptureingFlag = qfalse;
		}
	}
	else
	{
		if ( capture_ent_num != 0 && capture_ent_num != cent->currentState.number
			&& Distance(capturingflagent->lerpOrigin, cg_entities[cg.clientNum].lerpOrigin) <= cg_entities[capture_ent_num].currentState.otherEntityNum2)
		{// We're taking a different flag...
			cg.capturingFlag = qtrue;

			if (cg_entities[capture_ent_num].currentState.teamowner == TEAM_NONE)
				cg.captureFlagPercent = cg_entities[capture_ent_num].currentState.time2*2;
			else
				cg.captureFlagPercent = cg_entities[capture_ent_num].currentState.time2;

			if (cg_entities[capture_ent_num].currentState.teamowner == cg_entities[cg.clientNum].currentState.teamowner
				&& cg_entities[capture_ent_num].currentState.teamowner != TEAM_NONE)
				cg.recaptureingFlag = qtrue;
			else
				cg.recaptureingFlag = qfalse;
		}
		else
		{// No flags being captured currently...
			cg.captureFlagPercent = 0;
			cg.capturingFlag = qfalse;
		}
	}

	if (cg.captureFlagPercent < 0)
		cg.captureFlagPercent = 0;

	// show the flag base
	memset(&flagmodel, 0, sizeof(flagmodel));
	flagmodel.reType = RT_MODEL;
	VectorCopy( cent->lerpOrigin, flagmodel.lightingOrigin );
	VectorCopy( cent->lerpOrigin, flagmodel.origin );
	AnglesToAxis( cent->currentState.angles, flagmodel.axis );

	if (!flags_registerred)
	{// Register basic flag model ready for use...
		flags_registerred = qtrue;
		cgs.media.redFlagModel = trap->R_RegisterModel( "models/flags/r_flag.md3" );
		cgs.media.blueFlagModel = trap->R_RegisterModel( "models/flags/b_flag.md3" );
		cgs.media.neutralFlagModel = trap->R_RegisterModel( "models/flags/n_flag.md3" );

		cgs.media.redFlagRadarShader = trap->R_RegisterShader("gfx/radar/red_flag");
		cgs.media.blueFlagRadarShader = trap->R_RegisterShader("gfx/radar/blue_flag");
		cgs.media.neutralFlagRadarShader = trap->R_RegisterShader("gfx/radar/neutral_flag"); // Warzone...
	}

	if ( cent->currentState.teamowner == TEAM_RED ) {
		if (cent->currentState.modelindex && cent->currentState.modelindex >= 1) // Use a custom model...
			flagmodel.hModel = cgs.gameModels[cent->currentState.modelindex];
		else
			flagmodel.hModel = cgs.media.redFlagModel;
	}
	else if ( cent->currentState.teamowner == TEAM_BLUE ) {
		if (cent->currentState.modelindex2 && cent->currentState.modelindex2 >= 1) // Use a custom model...
			flagmodel.hModel = cgs.gameModels[cent->currentState.modelindex2];
		else
			flagmodel.hModel = cgs.media.blueFlagModel;
	}
	else {
		if (cent->currentState.activeForcePass && cent->currentState.activeForcePass >= 1) // Use a custom model...
			flagmodel.hModel = cgs.gameModels[cent->currentState.activeForcePass];
		else
			flagmodel.hModel = cgs.media.neutralFlagModel;
	}

	if (cent->currentState.eType != ET_NPC)
	{ //do not do this for g2animents
		trap->R_AddRefEntityToScene( &flagmodel );
	}
}


/*
===============
CG_Ammo_Crate
===============
*/
void CG_Ammo_Crate( centity_t *cent ) {
	refEntity_t		flagmodel;
	entityState_t	*cs;
	playerState_t	*ps;
	float			scale = 1.0f;

	cs = &cent->currentState;
	ps = &cg.predictedPlayerState;

	memset(&flagmodel, 0, sizeof(flagmodel));
	flagmodel.reType = RT_MODEL;

	VectorCopy( cent->lerpOrigin, flagmodel.lightingOrigin );
	VectorCopy( cent->lerpOrigin, flagmodel.origin );
	VectorCopy( cent->lerpOrigin, flagmodel.oldorigin);

	AnglesToAxis( cent->currentState.angles, flagmodel.axis );

	if (!cent->currentState.modelindex2)
		cent->currentState.modelindex2 = trap->R_RegisterModel( "models/doa/doa_cabinet/ammo_close.md3" );

	if (!cent->currentState.modelindex)
		cent->currentState.modelindex = trap->R_RegisterModel( "models/doa/doa_cabinet/ammo_open.md3" );

	if (cent->currentState.frame == 1)
		flagmodel.hModel = cgs.gameModels[cent->currentState.modelindex];
	else
		flagmodel.hModel = cgs.gameModels[cent->currentState.modelindex2];
	
	VectorScale( flagmodel.axis[0], scale, flagmodel.axis[0] );
	VectorScale( flagmodel.axis[1], scale, flagmodel.axis[1] );
	VectorScale( flagmodel.axis[2], scale, flagmodel.axis[2] );
	flagmodel.nonNormalizedAxes = qtrue;

	if (cent->currentState.eType != ET_NPC)
	{ //do not do this for NPCs
		trap->R_AddRefEntityToScene( &flagmodel );
	}
}

/*
===============
CG_Health_Crate
===============
*/
void CG_Health_Crate( centity_t *cent ) {
	refEntity_t		cratemodel;
	entityState_t	*cs;
	playerState_t	*ps;
	float			scale = 1.0f;

	cs = &cent->currentState;
	ps = &cg.predictedPlayerState;

	memset(&cratemodel, 0, sizeof(cratemodel));
	cratemodel.reType = RT_MODEL;

	VectorCopy( cent->lerpOrigin, cratemodel.lightingOrigin );
	VectorCopy( cent->lerpOrigin, cratemodel.origin );
	VectorCopy( cent->lerpOrigin, cratemodel.oldorigin);

	AnglesToAxis( cent->currentState.angles, cratemodel.axis );

	if (!cent->currentState.modelindex2)
		cent->currentState.modelindex2 = trap->R_RegisterModel( "models/doa/doa_cabinet/health_close.md3" );

	if (!cent->currentState.modelindex)
		cent->currentState.modelindex = trap->R_RegisterModel( "models/doa/doa_cabinet/health_open.md3" );

	if (cent->currentState.frame == 1)
		cratemodel.hModel = cgs.gameModels[cent->currentState.modelindex];
	else
		cratemodel.hModel = cgs.gameModels[cent->currentState.modelindex2];

	VectorScale( cratemodel.axis[0], scale, cratemodel.axis[0] );
	VectorScale( cratemodel.axis[1], scale, cratemodel.axis[1] );
	VectorScale( cratemodel.axis[2], scale, cratemodel.axis[2] );
	cratemodel.nonNormalizedAxes = qtrue;

	if (cent->currentState.eType != ET_NPC)
	{ //do not do this for NPCs
		trap->R_AddRefEntityToScene( &cratemodel );
	}
}


/*
=========================
CG_AdjustPositionForMover

Also called by client movement prediction code
=========================
*/
void CG_AdjustPositionForMover( const vec3_t in, int moverNum, int fromTime, int toTime, vec3_t out ) {
	centity_t	*cent;
	vec3_t	oldOrigin, origin, deltaOrigin;
	vec3_t	oldAngles, angles, deltaAngles;

	//Raz: Don't bother if we're a spectator
	if ( cg.predictedPlayerState.persistant[PERS_TEAM] == TEAM_SPECTATOR )
	{
		VectorCopy( in, out );
		return;
	}

	if ( moverNum <= 0 || moverNum >= ENTITYNUM_MAX_NORMAL ) {
		VectorCopy( in, out );
		return;
	}

	cent = &cg_entities[ moverNum ];
	if ( cent->currentState.eType != ET_MOVER ) {
		VectorCopy( in, out );
		return;
	}

	BG_EvaluateTrajectory( &cent->currentState.pos, fromTime, oldOrigin );
	BG_EvaluateTrajectory( &cent->currentState.apos, fromTime, oldAngles );

	BG_EvaluateTrajectory( &cent->currentState.pos, toTime, origin );
	BG_EvaluateTrajectory( &cent->currentState.apos, toTime, angles );

	VectorSubtract( origin, oldOrigin, deltaOrigin );
	VectorSubtract( angles, oldAngles, deltaAngles );

	VectorAdd( in, deltaOrigin, out );

	// FIXME: origin change when on a rotating object
}

/*
=============================
CG_InterpolateEntityPosition
=============================
*/
static void CG_InterpolateEntityPosition( centity_t *cent ) {
	vec3_t		current, next;
	float		f;

	// it would be an internal error to find an entity that interpolates without
	// a snapshot ahead of the current one
	if ( cg.nextSnap == NULL ) {
		trap->Error ( ERR_DROP, "CG_InterpoateEntityPosition: cg.nextSnap == NULL" );
		return;
	}

	f = cg.frameInterpolation;

	// this will linearize a sine or parabolic curve, but it is important
	// to not extrapolate player positions if more recent data is available
	BG_EvaluateTrajectory( &cent->currentState.pos, cg.snap->serverTime, current );
	BG_EvaluateTrajectory( &cent->nextState.pos, cg.nextSnap->serverTime, next );

	cent->lerpOrigin[0] = current[0] + f * ( next[0] - current[0] );
	cent->lerpOrigin[1] = current[1] + f * ( next[1] - current[1] );
	cent->lerpOrigin[2] = current[2] + f * ( next[2] - current[2] );

	BG_EvaluateTrajectory( &cent->currentState.apos, cg.snap->serverTime, current );
	BG_EvaluateTrajectory( &cent->nextState.apos, cg.nextSnap->serverTime, next );

	cent->lerpAngles[0] = LerpAngle( current[0], next[0], f );
	cent->lerpAngles[1] = LerpAngle( current[1], next[1], f );
	cent->lerpAngles[2] = LerpAngle( current[2], next[2], f );
}

/*
===============
CG_CalcEntityLerpPositions

===============
*/
void CG_CalcEntityLerpPositions( centity_t *cent ) {
	qboolean goAway = qfalse;

	// if this player does not want to see extrapolated players
	if ( !cg_smoothClients.integer ) {
		// make sure the clients use TR_INTERPOLATE
		if ( (cent->currentState.number != cg.clientNum && cent->currentState.number < MAX_CLIENTS) || cent->currentState.eType == ET_NPC ) { // UQ1: NPCs too pls!!!
			cent->currentState.pos.trType = TR_INTERPOLATE;
			cent->nextState.pos.trType = TR_INTERPOLATE;
		}
	}

	if ( cent->interpolate && cent->currentState.pos.trType == TR_INTERPOLATE ) {
		CG_InterpolateEntityPosition( cent );
		return;
	}

	// first see if we can interpolate between two snaps for
	// linear extrapolated clients
	if ( cent->interpolate && cent->currentState.pos.trType == TR_LINEAR_STOP
		&& ((cent->currentState.number != cg.clientNum && cent->currentState.number < MAX_CLIENTS) || cent->currentState.eType == ET_NPC) ) { // UQ1: NPCs too pls!!!
		CG_InterpolateEntityPosition( cent );
		goAway = qtrue;
	}
	else
	{
		// just use the current frame and evaluate as best we can
		BG_EvaluateTrajectory( &cent->currentState.pos, cg.time, cent->lerpOrigin );
		BG_EvaluateTrajectory( &cent->currentState.apos, cg.time, cent->lerpAngles );
	}

#if 0
	if (cent->hasRagOffset && cent->ragOffsetTime < cg.time)
	{ //take all of the offsets from last frame and normalize the total direction and add it in
		vec3_t slideDir;
		vec3_t preOffset;
		vec3_t addedOffset;
		vec3_t	playerMins = {-15, -15, DEFAULT_MINS_2};
		vec3_t	playerMaxs = {15, 15, DEFAULT_MAXS_2};
		trace_t tr;

		//VectorSubtract(cent->lerpOrigin, callData->bonePos, slideDir);
		VectorCopy(cent->ragOffsets, slideDir);
		VectorNormalize(slideDir);

		//Store it in case we want to go back
		VectorCopy(cent->lerpOriginOffset, preOffset);

		//just add a little at a time
		VectorMA(cent->lerpOriginOffset, 0.4f, slideDir, cent->lerpOriginOffset);

		if (VectorLength(cent->lerpOriginOffset) > 10.0f)
		{ //don't go too far away
			VectorCopy(preOffset, cent->lerpOriginOffset);
		}
		else
		{
			//Let's trace there to make sure we can make it
			VectorAdd(cent->lerpOrigin, cent->lerpOriginOffset, addedOffset);
			CG_Trace(&tr, cent->lerpOrigin, playerMins, playerMaxs, addedOffset, cent->currentState.number, MASK_PLAYERSOLID);

			if (tr.startsolid || tr.allsolid || tr.fraction != 1.0f)
			{ //can't get there
				VectorCopy(preOffset, cent->lerpOriginOffset);
			}
			else
			{
				/*
				if (cent->lerpOriginOffset[2] > 4.0f)
				{ //don't go too far off the ground
					cent->lerpOriginOffset[2] = 4.0f;
				}
				*/
				//I guess I just don't want this happening.
				cent->lerpOriginOffset[2] = 0.0f;
			}
		}

		//done with this bit
		cent->hasRagOffset = qfalse;
		VectorClear(cent->ragOffsets);
		cent->ragOffsetTime = cg.time + 50;
	}

	//See if we should add in the offset for ragdoll
	if (cent->isRagging && ((cent->currentState.eFlags & EF_DEAD) || (cent->currentState.eFlags & EF_RAG)))
	{
		VectorAdd(cent->lerpOrigin, cent->lerpOriginOffset, cent->lerpOrigin);
	}
#endif

	if (goAway)
	{
		return;
	}

	// adjust for riding a mover if it wasn't rolled into the predicted
	// player state
	if ( cent->currentState.number != cg.clientNum ) {
		CG_AdjustPositionForMover( cent->lerpOrigin, cent->currentState.groundEntityNum, 
		cg.snap->serverTime, cg.time, cent->lerpOrigin );
	}
}

void CG_G2Animated( centity_t *cent );

static void CG_FX( centity_t *cent ) 
{
	vec3_t			fxDir;
	int				efxIndex = 0;
	entityState_t	*s1;
	const char		*s;

	if (cent->miscTime > cg.time)
	{
		return;
	}

	s1 = &cent->currentState;

	if (!s1)
	{
		return;
	}

	if (s1->modelindex2 == FX_STATE_OFF)
	{	// fx not active
		return;
	}

	if (s1->modelindex2 < FX_STATE_ONE_SHOT_LIMIT)
	{	// fx is single shot
		if (cent->muzzleFlashTime == s1->modelindex2)
		{
			return;
		}

		cent->muzzleFlashTime = s1->modelindex2;
	}

	cent->miscTime = cg.time + s1->speed + random() * s1->time;

	AngleVectors(s1->angles, fxDir, 0, 0);
	
	if (!fxDir[0] && !fxDir[1] && !fxDir[2])
	{
		fxDir[1] = 1;
	}

	if ( cgs.gameEffects[ s1->modelindex ] )
	{
		efxIndex = cgs.gameEffects[s1->modelindex];
	}
	else
	{
		s = CG_ConfigString( CS_EFFECTS + s1->modelindex );
		if (s && s[0])
		{
			efxIndex = trap->FX_RegisterEffect(s);
			cgs.gameEffects[s1->modelindex] = efxIndex;
		}
	}

	if (efxIndex)
	{
		if (s1->isPortalEnt)
		{
			trap->FX_PlayEffectID(efxIndex, cent->lerpOrigin, fxDir, -1, -1, true );
		}
		else
		{
			trap->FX_PlayEffectID(efxIndex, cent->lerpOrigin, fxDir, -1, -1, false );
		}
	}


}


/*
===============
CG_AddCEntity

===============
*/
static void CG_AddCEntity( centity_t *cent ) {
	// event-only entities will have been dealt with already
	if ( cent->currentState.eType >= ET_EVENTS ) {
		return;
	}

	if (cg.predictedPlayerState.pm_type == PM_INTERMISSION)
	{ //don't render anything then
		if (cent->currentState.eType == ET_GENERAL ||
			cent->currentState.eType == ET_PLAYER ||
			cent->currentState.eType == ET_INVISIBLE)
		{
			return;
		}
	}

	//Raz: don't render when we are in spec, happens occasionally on map_restart and such
	if ( cg.predictedPlayerState.clientNum == cent->currentState.number && cg.predictedPlayerState.persistant[PERS_TEAM] == TEAM_SPECTATOR )
		return;


	// calculate the current origin
	CG_CalcEntityLerpPositions( cent );

	// add automatic effects
	CG_EntityEffects( cent );
/*
Ghoul2 Insert Start
*/

	// add local sound set if any
	if ( cent->currentState.soundSetIndex && cent->currentState.eType != ET_MOVER )
	{
		const char *soundSet = CG_ConfigString( CS_AMBIENT_SET + cent->currentState.soundSetIndex );

		if (soundSet && soundSet[0])
		{
			trap->S_AddLocalSet(soundSet, cg.refdef.vieworg, cent->lerpOrigin, cent->currentState.number, cg.time);
		}
	}
/*
Ghoul2 Insert End
*/
	switch ( cent->currentState.eType ) {
	default:
		trap->Error( ERR_DROP, "Bad entity type: %i\n", cent->currentState.eType );
		break;

	case ET_FX:
		CG_FX( cent );
		break;

	case ET_INVISIBLE:
	case ET_PUSH_TRIGGER:
	case ET_TELEPORT_TRIGGER:
	case ET_TERRAIN:
		break;
	case ET_GENERAL:
		CG_General( cent );
		break;
	case ET_PLAYER:
		CG_Player( cent );
		break;
	case ET_ITEM:
		CG_Item( cent );
		break;
	case ET_MISSILE:
		CG_Missile( cent );
		break;
	case ET_SPECIAL:
		CG_Special( cent );
		break;
	case ET_MOVER:
		CG_Mover( cent );
		break;
	case ET_BEAM:
		CG_Beam( cent );
		break;
	case ET_PORTAL:
		CG_Portal( cent );
		break;
	case ET_SPEAKER:
		CG_Speaker( cent );
		break;
	case ET_NPC: //An entity that wants to be able to use ghoul2 humanoid (and other) anims. Like a player, but not.
		CG_G2Animated( cent );
		break;
	case ET_TEAM:
		break;
	case ET_BODY:
		CG_General( cent );
		break;
	case ET_FLAG:
		CG_Flag( cent );
		break;
	case ET_AMMO_CRATE:
		CG_Ammo_Crate( cent );
		break;
	case ET_HEALTH_CRATE:
		CG_Health_Crate( cent );
		break;
	}
}

void CG_ManualEntityRender(centity_t *cent)
{
	CG_AddCEntity(cent);
}

#ifdef __AUTOWAYPOINT__
void DrawWaypoints();
#endif //__AUTOWAYPOINT__

/*
===============
CG_AddPacketEntities

===============
*/
void CG_TransitionEntity( centity_t *cent );
void CG_AddPacketEntities( qboolean isPortal ) {
	int					num;
	centity_t			*cent;
	playerState_t		*ps;

#ifdef __AUTOWAYPOINT__
	DrawWaypoints();
#endif //__AUTOWAYPOINT__

	if (isPortal)
	{
		for ( num = 0 ; num < cg.snap->numEntities ; num++ )
		{
			cent = &cg_entities[ cg.snap->entities[ num ].number ];

			if (cent->currentState.isPortalEnt)
			{
				CG_AddCEntity( cent );
			}
		}
		return;
	}

	// set cg.frameInterpolation
	if ( cg.nextSnap ) {
		int		delta;

		delta = (cg.nextSnap->serverTime - cg.snap->serverTime);
		if ( delta == 0 ) {
			cg.frameInterpolation = 0;
		} else {
			cg.frameInterpolation = (float)( cg.time - cg.snap->serverTime ) / delta;
		}
	} else {
		cg.frameInterpolation = 0;	// actually, it should never be used, because 
									// no entities should be marked as interpolating
	}

	// the auto-rotating items will all have the same axis
	cg.autoAngles[0] = 0;
	cg.autoAngles[1] = ( cg.time & 2047 ) * 360 / 2048.0f;
	cg.autoAngles[2] = 0;

	cg.autoAnglesFast[0] = 0;
	cg.autoAnglesFast[1] = ( cg.time & 1023 ) * 360 / 1024.0f;
	cg.autoAnglesFast[2] = 0;

	AnglesToAxis( cg.autoAngles, cg.autoAxis );
	AnglesToAxis( cg.autoAnglesFast, cg.autoAxisFast );

	// Reset radar entities
	cg.radarEntityCount = 0;

	// generate and add the entity from the playerstate
	ps = &cg.predictedPlayerState;

	CG_CheckPlayerG2Weapons(ps, &cg_entities[cg.predictedPlayerState.clientNum]);
	BG_PlayerStateToEntityState( ps, &cg_entities[cg.predictedPlayerState.clientNum].currentState, qfalse );

	CG_AddCEntity( &cg_entities[cg.predictedPlayerState.clientNum] );
	
	if ( cg.nextSnap )
	{
	    for ( num = 0; num < cg.nextSnap->numEntities; num++ )
	    {
	        cent = &cg_entities[cg.nextSnap->entities[num].number];
	        if ( cent->nextState.eType == ET_MISSILE || cent->nextState.eType == ET_GENERAL )
	        {
	            CG_TransitionEntity (cent);
	            cent->interpolate = qtrue;
	            
	            CG_AddCEntity (cent);
	        }
	    }
	}

	// add each entity sent over by the server
	for ( num = 0 ; num < cg.snap->numEntities ; num++ ) {
		// Don't re-add ents that have been predicted.
		if (cg.snap->entities[ num ].number != cg.snap->ps.clientNum)
		{
			cent = &cg_entities[ cg.snap->entities[ num ].number ];
			if ( cg.nextSnap && (cent->currentState.eType == ET_MISSILE || cent->currentState.eType == ET_GENERAL) )
			{
			    continue;
			}
			
			CG_AddCEntity( cent );
		}
	}

	for(num=0;num<cg_numpermanents;num++)
	{
		cent = cg_permanents[num];
		if (cent->currentValid)
		{
			CG_AddCEntity( cent );
		}
	}
}

void CG_ROFF_NotetrackCallback( centity_t *cent, const char *notetrack)
{
	int i = 0, r = 0, objectID = 0, anglesGathered = 0, posoffsetGathered = 0;
	char type[256];
	char argument[512];
	char addlArg[512];
	char errMsg[256];
	char t[64];
	int addlArgs = 0;
	vec3_t parsedAngles, parsedOffset, useAngles, useOrigin, forward, right, up;

	if (!cent || !notetrack)
	{
		return;
	}

	//notetrack = "effect effects/explosion1.efx 0+0+64 0-0-1";

	while (notetrack[i] && notetrack[i] != ' ')
	{
		type[i] = notetrack[i];
		i++;
	}

	type[i] = '\0';

	if (notetrack[i] != ' ')
	{ //didn't pass in a valid notetrack type, or forgot the argument for it
		return;
	}

	i++;

	while (notetrack[i] && notetrack[i] != ' ')
	{
		argument[r] = notetrack[i];
		r++;
		i++;
	}
	argument[r] = '\0';

	if (!r)
	{
		return;
	}

	if (notetrack[i] == ' ')
	{ //additional arguments...
		addlArgs = 1;

		i++;
		r = 0;
		while (notetrack[i])
		{
			addlArg[r] = notetrack[i];
			r++;
			i++;
		}
		addlArg[r] = '\0';
	}

	if (strcmp(type, "effect") == 0)
	{
		if (!addlArgs)
		{
			//sprintf(errMsg, "Offset position argument for 'effect' type is invalid.");
			//goto functionend;
			VectorClear(parsedOffset);
			goto defaultoffsetposition;
		}

		i = 0;

		while (posoffsetGathered < 3)
		{
			r = 0;
			while (addlArg[i] && addlArg[i] != '+' && addlArg[i] != ' ')
			{
				t[r] = addlArg[i];
				r++;
				i++;
			}
			t[r] = '\0';
			i++;
			if (!r)
			{ //failure..
				//sprintf(errMsg, "Offset position argument for 'effect' type is invalid.");
				//goto functionend;
				VectorClear(parsedOffset);
				i = 0;
				goto defaultoffsetposition;
			}
			parsedOffset[posoffsetGathered] = atof(t);
			posoffsetGathered++;
		}

		if (posoffsetGathered < 3)
		{
			Com_sprintf(errMsg, sizeof(errMsg), "Offset position argument for 'effect' type is invalid.");
			goto functionend;
		}

		i--;

		if (addlArg[i] != ' ')
		{
			addlArgs = 0;
		}

defaultoffsetposition:

		objectID = trap->FX_RegisterEffect(argument);

		if (objectID)
		{
			if (addlArgs)
			{ //if there is an additional argument for an effect it is expected to be XANGLE-YANGLE-ZANGLE
				i++;
				while (anglesGathered < 3)
				{
					r = 0;
					while (addlArg[i] && addlArg[i] != '-')
					{
						t[r] = addlArg[i];
						r++;
						i++;
					}
					t[r] = '\0';
					i++;

					if (!r)
					{ //failed to get a new part of the vector
						anglesGathered = 0;
						break;
					}

					parsedAngles[anglesGathered] = atof(t);
					anglesGathered++;
				}

				if (anglesGathered)
				{
					VectorCopy(parsedAngles, useAngles);
				}
				else
				{ //failed to parse angles from the extra argument provided..
					VectorCopy(cent->lerpAngles, useAngles);
				}
			}
			else
			{ //if no constant angles, play in direction entity is facing
				VectorCopy(cent->lerpAngles, useAngles);
			}

			AngleVectors(useAngles, forward, right, up);

			VectorCopy(cent->lerpOrigin, useOrigin);

			//forward
			useOrigin[0] += forward[0]*parsedOffset[0];
			useOrigin[1] += forward[1]*parsedOffset[0];
			useOrigin[2] += forward[2]*parsedOffset[0];

			//right
			useOrigin[0] += right[0]*parsedOffset[1];
			useOrigin[1] += right[1]*parsedOffset[1];
			useOrigin[2] += right[2]*parsedOffset[1];

			//up
			useOrigin[0] += up[0]*parsedOffset[2];
			useOrigin[1] += up[1]*parsedOffset[2];
			useOrigin[2] += up[2]*parsedOffset[2];

			trap->FX_PlayEffectID(objectID, useOrigin, useAngles, -1, -1, false);
		}
	}
	else if (strcmp(type, "sound") == 0)
	{
		objectID = trap->S_RegisterSound(argument);
		trap->S_StartSound(cent->lerpOrigin, cent->currentState.number, CHAN_BODY, objectID);
	}
	else if (strcmp(type, "loop") == 0)
	{ //handled server-side
		return;
	}
	//else if ...
	else
	{
		if (type[0])
		{
			Com_Printf("^3Warning: \"%s\" is an invalid ROFF notetrack function\n", type);
		}
		else
		{
			Com_Printf("^3Warning: Notetrack is missing function and/or arguments\n");
		}
	}

	return;

functionend:
	Com_Printf("^3Type-specific notetrack error: %s\n", errMsg);
	return;
}

void CG_Cube( vec3_t mins, vec3_t maxs, vec3_t color, float alpha ) 
{
	vec3_t	rot={0,0,0};
	int		vec[3];
	int		axis, i;
	addpolyArgStruct_t apArgs;

	memset (&apArgs, 0, sizeof(apArgs));

	for ( axis = 0, vec[0] = 0, vec[1] = 1, vec[2] = 2; axis < 3; axis++, vec[0]++, vec[1]++, vec[2]++ )
	{
		for ( i = 0; i < 3; i++ )
		{
			if ( vec[i] > 2 )
			{
				vec[i] = 0;
			}
		}

		apArgs.p[0][vec[1]] = mins[vec[1]];
		apArgs.p[0][vec[2]] = mins[vec[2]];

		apArgs.p[1][vec[1]] = mins[vec[1]];
		apArgs.p[1][vec[2]] = maxs[vec[2]];

		apArgs.p[2][vec[1]] = maxs[vec[1]];
		apArgs.p[2][vec[2]] = maxs[vec[2]];
		
		apArgs.p[3][vec[1]] = maxs[vec[1]];
		apArgs.p[3][vec[2]] = mins[vec[2]];

		//- face
		apArgs.p[0][vec[0]] = apArgs.p[1][vec[0]] = apArgs.p[2][vec[0]] = apArgs.p[3][vec[0]] = mins[vec[0]];

		apArgs.numVerts = 4;
		apArgs.alpha1 = apArgs.alpha2 = alpha;
		VectorCopy( color, apArgs.rgb1 );
		VectorCopy( color, apArgs.rgb2 );
		VectorCopy( rot, apArgs.rotationDelta );
		apArgs.killTime = cg.frametime;
		apArgs.shader = cgs.media.solidWhite;

		trap->FX_AddPoly( &apArgs );

		//+ face
		apArgs.p[0][vec[0]] = apArgs.p[1][vec[0]] = apArgs.p[2][vec[0]] = apArgs.p[3][vec[0]] = maxs[vec[0]];

		trap->FX_AddPoly( &apArgs );
	}
}
