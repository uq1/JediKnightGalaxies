#include "g_local.h"
#include "jkg_treasureclass.h"
#include "bg_items.h"
#include <json/cJSON.h>

#define MAX_TC_SIZE		32768

std::unordered_map<std::string, TreasureClass*> umTreasureClasses;

// Creates the treasure class
#define DEFAULT_PICK_COUNT	1
TreasureClass::TreasureClass(const char* szName, cJSON* pJSON) {

	pSeed = new RNGenerator(0);
	szClassName = szName;
	nTotalOdds = 0;
	nNumberPicksMin = nNumberPicksMax = DEFAULT_PICK_COUNT;
	if (pJSON == nullptr) {
		// Autogenerated
		TreasureEntry te;
		te.tc.nItem = BG_FindItemByInternal(szName);
		te.nOdds = 1;
		te.bResolved = true;
		vTreasure.push_back(te);
		bAutogenerated = true;
		return;
	}
	bAutogenerated = false;

	// Treasure class fields
	cJSON* pObject = cJSON_GetObjectItem(pJSON, "numberPicksMin");
	nNumberPicksMin = cJSON_ToIntegerOpt(pObject, DEFAULT_PICK_COUNT);
	pObject = cJSON_GetObjectItem(pJSON, "numberPicksMax");
	nNumberPicksMax = cJSON_ToIntegerOpt(pObject, DEFAULT_PICK_COUNT);
	pObject = cJSON_GetObjectItem(pJSON, "uniquePicks");
	bUniquePicks = cJSON_ToBooleanOpt(pObject, false);

	pObject = cJSON_GetObjectItem(pJSON, "picks");
	for (cJSON* pTreasure = cJSON_GetFirstItem(pObject); pTreasure; pTreasure = cJSON_GetNextItem(pTreasure)) {
		TreasureEntry te;
		memset(&te, 0, sizeof(te));

		Q_strncpyz(te.tc.szTreasureClass, Q_strlwr((char*)cJSON_GetItemKey(pTreasure)), MAX_QPATH);
		te.nOdds = cJSON_ToInteger(pTreasure);
		te.bResolved = false;
		vTreasure.push_back(te);
		nTotalOdds += te.nOdds;
	}
}

TreasureClass::~TreasureClass() {
	delete pSeed;
}

// Fills items into a vector storage by using the treasure class picks
void TreasureClass::Pick(std::vector<int>& rtItems, int32_t nSeed) {
	pSeed->Reseed(nSeed);

	if (nNumberPicksMax == 0)
	{	// can't pick any items, don't bother with this
		return;
	}

	int32_t nItemCount = pSeed->Irand(nNumberPicksMin, nNumberPicksMax);
	for (int i = 0; i < nItemCount; i++) {
		bool bDidntFind = false;
		int nItemPicked = PickSingle(pSeed->rand());
		if (nItemPicked == -1)
		{
			// failed to pick an item for this treasure class
			Com_Printf("failed to pick for TC: %s\n", szClassName.c_str());
			return;
		}
		if (bUniquePicks) {	// Did we pick an item that we already have in this list? If so, we shouldn't add it.
			for (auto it = rtItems.begin(); it != rtItems.end(); ++it) {
				if (*it == nItemPicked) {
					bDidntFind = true;
					break;
				}
			}
			if (bDidntFind) {
				i--;
				continue;
			}
		}
		rtItems.push_back(nItemPicked);
	}
}

// Picks a single item from a treasure class
int TreasureClass::PickSingle(int32_t nSeed) {
	pSeed->Reseed(nSeed);

	if (bAutogenerated) {
		// Autogenerated treasure class -> base case of recursion
		return vTreasure.begin()->tc.nItem;
	}

	if (nTotalOdds == 0)
	{
		return -1;
	}

	int nOdds = pSeed->Irand(0, nTotalOdds-1);
	auto it = vTreasure.begin();

	for (int i = 0; it != vTreasure.end() && i + it->nOdds < nOdds; ++it) {
		i += it->nOdds;
	}

	if (it == vTreasure.end()) {
		// something bad happened, just use 0 as odds
		it = vTreasure.begin();
	}

	TreasureClass* pTC;
	std::string sTreasureClass = it->tc.szTreasureClass;
	if (!it->bResolved) {
		pTC = umTreasureClasses[sTreasureClass];
	}
	else {
		pTC = it->tc.pTreasureClass;
	}

	// print a warning if we didn't get a good TC reference here, and repick
	if (pTC == nullptr)
	{
		Com_Printf("^3WARNING: Could not resolve TC reference %s\n", sTreasureClass.c_str());
		return PickSingle(pSeed->rand());
	}

	return pTC->PickSingle(pSeed->rand());
}

// Debug feature: prints a list of items that drop and their percent drop chance
#ifdef _GAME
void TreasureClass::PrintDropRates(gentity_t* ent, int nSamples, bool bMulti) {
	std::map<int, int> mDropCounts;
	for (int i = 0; i < nSamples; i++) {
		if (!bMulti) {
			int nItemPicked = PickSingle(pSeed->rand());
			if (nItemPicked == -1)
			{
				Com_Printf("Drop rate evaluation failed; make sure the treasure class has items in it, and everything has positive odds!\n");
				return;
			}
			mDropCounts[nItemPicked]++;
		}
		else {
			std::vector<int> vItems;
			Pick(vItems, pSeed->rand());
			for (auto it = vItems.begin(); it != vItems.end(); ++it) {
				mDropCounts[*it]++;
			}
		}
	}
	trap->SendServerCommand(ent - g_entities, va("print \"Drop chances at %i samples:\n\"", nSamples));
	for (auto it = mDropCounts.begin(); it != mDropCounts.end(); ++it) {
		int nItemID = it->first;
		int nCount = it->second;
		float fPercent = (nCount / (float)nSamples) * 100.0f;
		itemData_t* pItemData = &itemLookupTable[nItemID];
		trap->SendServerCommand(ent - g_entities, va("print \"%s dropped %i times\t\t(%3.2f%%)\n\"", pItemData->internalName, nCount, fPercent));
	}
}
#endif

// Automatically cleans treasureclasses of potential errors
// There are two potential Very Bad Things that can happen due to developer error:
// 1. Stack overflow - occurs when treasureclasses infinitely nest
// 2. Infinite loop - occurs when there aren't enough "picks" in a treasureclass when "repeat" is turned off.
void TreasureClass::Clean() {
	// First step - prevent stack overflow
	StackGuard(szClassName);

	// Second step - prevent infinite loops
	if (bUniquePicks) {
		int nNumberItems = GetNumberOfUniqueItems();
		if (nNumberPicksMin <= 0) {
			Com_Printf("^3Found a treasure class (\"%s\") with uniquePicks set, but numberPicksMin set to 0 or below!\n", szClassName.c_str());
			nNumberPicksMin = 1;
		}
		else if (nNumberPicksMax > nNumberItems) {
			Com_Printf("^3Found a treasure class (\"%s\") with uniquePicks and numberPicksMax > number of unique items!\n", szClassName.c_str());
			nNumberPicksMax = 1;
		}
	}
	if (nNumberPicksMin > nNumberPicksMax) {
		Com_Printf("^3Found a treasure class (\"%s\") with numberPicksMin > numberPicksMax!\n", szClassName.c_str());
		nNumberPicksMin = nNumberPicksMax;
	}
}

void TreasureClass::StackGuard(const std::string& szCheck) {
	if (bAutogenerated) {
		return;
	}
	for (auto it = vTreasure.begin(); it != vTreasure.end(); ++it) {
		if (it->tc.szTreasureClass != nullptr) {
			// Go ahead and resolve it
			if (szCheck == it->tc.szTreasureClass) {
				Com_Printf("^3Found a treasure class which loops on itself (\"%s\"), removing looping element...\n", szCheck.c_str());
				it = vTreasure.erase(it);
			}
			else {
				// Recurse over it
				std::string sSearchString = it->tc.szTreasureClass;
				auto it2 = umTreasureClasses.find(sSearchString);
				if (it2 == umTreasureClasses.end()) //check if wasn't found
				{
					//not sure how to proceed with this case where we hit end	--futuza
					Com_Printf("^3\"%s\" not found in treasure class!\n", sSearchString.c_str());
					continue;
				}
				it->tc.pTreasureClass = it2->second;
				it->tc.pTreasureClass->StackGuard(szCheck);
			}
		}
	}
}

// Warning: this function assumes that all treasure classes have been resolved ahead of time!!
int TreasureClass::GetNumberOfUniqueItems() {
	int nNumItems = 0;
	if (bAutogenerated) {
		return 1;
	}
	for (auto it = vTreasure.begin(); it != vTreasure.end(); ++it) {
		nNumItems += it->tc.pTreasureClass->GetNumberOfUniqueItems();
	}
	return nNumItems;
}


// Autogenerates a series of treasure classes based on internals of items
static void JKG_TC_Autogenerate() {
	for (int i = 0; i < lastUsedItemID; i++) {
		itemData_t* pItemData = &itemLookupTable[i];
		char* szLower = Q_strlwr(pItemData->internalName);
		std::string sLower = szLower;
		TreasureClass* pTC = new TreasureClass(szLower);
		umTreasureClasses[sLower] = pTC;
	}
}

// Read a single treasureclass .json file
static void JKG_TC_File(const char* szTCFile) {
	fileHandle_t f;
	int nFileLen = trap->FS_Open(szTCFile, &f, FS_READ);
	char szContents[MAX_TC_SIZE];
	if (nFileLen <= 0) {
		return;
	}
	else if (nFileLen >= MAX_TC_SIZE) {
		Com_Printf("^1ERROR - TreasureClass file %s is too big (> %i kb)\n", szTCFile, MAX_TC_SIZE / 1024);
		return;
	}

	trap->FS_Read(szContents, nFileLen, f);
	trap->FS_Close(f);
	szContents[nFileLen] = '\0';

	char szError[1024];
	cJSON* json = cJSON_ParsePooled(szContents, szError, sizeof(szError));

	if (json == nullptr) {
		Com_Printf("^1ERROR reading TC %s: %s\n", szTCFile, szError);
		return;
	}
	
	cJSON* root = cJSON_GetObjectItem(json, "classes");
	if (root == nullptr) {
		Com_Printf("^1ERROR in %s, no 'classes' node\n", szTCFile);
		return;
	}

	cJSON* item = nullptr;
	for (item = cJSON_GetFirstItem(root); item; item = cJSON_GetNextItem(item)) {
		const char* szObjName = cJSON_GetItemKey(item);
		char* szLower = Q_strlwr((char*)szObjName);
		std::string sLower = szLower;
		TreasureClass* pTreasureClass = new TreasureClass(szLower, item);
		umTreasureClasses[sLower] = pTreasureClass;
	}
}

void JKG_TC_Init(const char* szTCDirectory) {
	char szTreasureClasses[32967];
	int nNumFiles = trap->FS_GetFileList(szTCDirectory, ".json", szTreasureClasses, sizeof(szTreasureClasses));
	char* szTreasureClass = szTreasureClasses;

	// Autogenerate TCs based on item internals
	JKG_TC_Autogenerate();

	for (int i = 0; i < nNumFiles; i++) {
		JKG_TC_File(va("%s/%s", szTCDirectory, szTreasureClass));
		szTreasureClass += strlen(szTreasureClass) + 1;
	}

	// Check if we should autoresolve classes
	if (trap->Cvar_VariableIntegerValue("jkg_safeTreasureClasses") != 0) {
		int numCleaned = 0;
		Com_Printf("jkg_safeTreasureClasses is turned on, performing cleanup...\n");
		for (auto it = umTreasureClasses.begin(); it != umTreasureClasses.end(); ++it) {
			it->second->Clean();
			numCleaned++;
		}
		Com_Printf("%i treasure classes checked, any warnings noted above.\n");
	}
}

void JKG_TC_Shutdown() {
	for (auto it = umTreasureClasses.begin(); it != umTreasureClasses.end(); ++it) {
		delete it->second;
	}
	umTreasureClasses.clear();
}