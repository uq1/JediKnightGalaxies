#pragma once
#include <vector>
#include <map>
#include <unordered_map>
#include <random>
#include <json/cJSON.h>

class TreasureClass;
struct TreasureEntry;

// An individual entry in a treasure class.
struct TreasureEntry {
	union{
		TreasureClass* pTreasureClass;				// Resolved treasure class
		char szTreasureClass[MAX_QPATH];			// Unresolved treasure class
		int nItem;									// Points to an item, not another treasure class
	} tc;

	int nOdds;
	bool bResolved;
};

// A treasure class. Can be part or all of a .json file
class TreasureClass {
	std::vector<TreasureEntry> vTreasure;
	std::string szClassName;			// FIXME
	int nTotalOdds;

	bool bAutogenerated;
	RNGenerator* pSeed;

	bool bUniquePicks;
	int nNumberPicksMin;
	int nNumberPicksMax;
public:
	TreasureClass(const char* szName, cJSON* pJSON = nullptr);
	~TreasureClass();

	void Pick(std::vector<int>& rtItems, int32_t nSeed);
	int PickSingle(int32_t nSeed);

#ifdef _GAME
	void PrintDropRates(gentity_t* ent, int nSamples, bool bMulti); // Debug feature
#endif

	void Clean();
	void StackGuard(const std::string& szCompare);
	void CountGuard();
	int GetNumberOfUniqueItems();
};

// Resolution table
extern std::unordered_map<std::string, TreasureClass*> umTreasureClasses;

void JKG_TC_Init(const char* szTCDirectory);
void JKG_TC_Shutdown();